{
  List<ScheduledEntry<K,V>> res=new ArrayList<ScheduledEntry<K,V>>(keys.size());
  Set<CompositeKey> candidateKeys=new HashSet<CompositeKey>();
  Set processedKeys=new HashSet();
  for (  Object key : keys) {
    for (    Object skey : secondsOfKeys.keySet()) {
      CompositeKey compositeKey=(CompositeKey)skey;
      if (key.equals(compositeKey.getKey())) {
        candidateKeys.add(compositeKey);
      }
    }
  }
  for (  CompositeKey compositeKey : candidateKeys) {
    final Integer second=secondsOfKeys.remove(compositeKey);
    if (second != null) {
      final ConcurrentMap<Object,ScheduledEntry<K,V>> entries=scheduledEntries.get(second);
      if (entries != null) {
        res.add(entries.remove(compositeKey));
        processedKeys.add(compositeKey.getKey());
      }
    }
  }
  entryProcessor.process(this,sortForEntryProcessing(res));
  return processedKeys;
}
