{
  if (scheduleType.equals(ScheduleType.FOR_EACH)) {
    return flushByCompositeKeys(keys);
  }
  List<ScheduledEntry<K,V>> res=new ArrayList<ScheduledEntry<K,V>>(keys.size());
  Set<K> processedKeys=new HashSet<K>();
  for (  K key : keys) {
    final Integer second=secondsOfKeys.remove(key);
    if (second != null) {
      final ConcurrentMap<Object,ScheduledEntry<K,V>> entries=scheduledEntries.get(second);
      if (entries != null) {
        processedKeys.add(key);
        res.add(entries.remove(key));
      }
    }
  }
  entryProcessor.process(this,sortForEntryProcessing(res));
  return processedKeys;
}
