{
  final HazelcastInstance instance=Hazelcast.newHazelcastInstance(new Config());
  final int threads=10;
  final IMap<Object,Object> testMap=instance.getMap("testConcurrentLockPrimitive");
  assertNull(testMap.putIfAbsent(1L,0L));
  assertEquals(0L,testMap.get(1L));
  final AtomicLong count=new AtomicLong(0);
  final ExecutorService pool=Executors.newFixedThreadPool(threads);
  final int total=50000;
  final CountDownLatch countDownLatch=new CountDownLatch(total);
  final Set<Long> values=new ConcurrentHashSet<Long>();
  for (int i=0; i < threads; i++) {
    pool.execute(new Runnable(){
      public void run(){
        while (count.incrementAndGet() < total + 1) {
          Long v=(Long)testMap.get(1L);
          assertNotNull(v);
          testMap.lock(1L);
          try {
            Long value=(Long)testMap.get(1L);
            if (!values.add(value)) {
              fail(value + " already exist!");
            }
            assertNotNull(value);
            testMap.put(1L,value + 1);
          }
  finally {
            testMap.unlock(1L);
            countDownLatch.countDown();
          }
        }
      }
    }
);
  }
  countDownLatch.await();
  pool.shutdown();
  assertTrue(pool.awaitTermination(5,TimeUnit.SECONDS));
  Long value=(Long)testMap.get(1L);
  assertEquals(Long.valueOf(total),value);
}
