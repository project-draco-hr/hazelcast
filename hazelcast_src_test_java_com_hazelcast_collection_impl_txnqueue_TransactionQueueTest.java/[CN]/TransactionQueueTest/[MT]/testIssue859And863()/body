{
  final int numberOfMessages=2000;
  final AtomicInteger count=new AtomicInteger();
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(2);
  final HazelcastInstance instance1=factory.newHazelcastInstance();
  final HazelcastInstance instance2=factory.newHazelcastInstance();
  final String inQueueName="in";
  final String outQueueName="out";
  for (int i=0; i < numberOfMessages; i++) {
    if (!instance1.getQueue(inQueueName).offer(i)) {
      throw new RuntimeException("initial put did not work");
    }
  }
class MoveMessage extends Thread {
    private final HazelcastInstance hazelcastInstance;
    private final String inQueueName;
    private final String outQueueName;
    private volatile boolean active=true;
    public MoveMessage(    HazelcastInstance hazelcastInstance,    String inQueueName,    String outQueueName){
      this.hazelcastInstance=hazelcastInstance;
      this.inQueueName=inQueueName;
      this.outQueueName=outQueueName;
    }
    public void run(){
      while (active && count.get() != numberOfMessages && hazelcastInstance.getLifecycleService().isRunning()) {
        TransactionContext transactionContext=hazelcastInstance.newTransactionContext();
        try {
          transactionContext.beginTransaction();
        }
 catch (        HazelcastInstanceNotActiveException ignored) {
          break;
        }
        try {
          TransactionalQueue<Object> queue=transactionContext.getQueue(inQueueName);
          Object value=queue.poll();
          if (value != null) {
            TransactionalQueue<Object> outQueue=transactionContext.getQueue(outQueueName);
            if (!outQueue.offer(value)) {
              throw new RuntimeException();
            }
          }
          transactionContext.commitTransaction();
          if (value != null) {
            count.incrementAndGet();
          }
        }
 catch (        Exception e) {
          try {
            transactionContext.rollbackTransaction();
          }
 catch (          HazelcastInstanceNotActiveException ignored) {
          }
        }
      }
    }
  }
  MoveMessage moveMessage1=new MoveMessage(instance1,inQueueName,outQueueName);
  MoveMessage moveMessage2=new MoveMessage(instance2,inQueueName,outQueueName);
  moveMessage1.start();
  moveMessage2.start();
  while (count.get() < numberOfMessages / 2) {
    sleepMillis(1);
  }
  instance2.getLifecycleService().terminate();
  moveMessage2.active=false;
  moveMessage2.join(10000);
  moveMessage1.join(10000);
  try {
    assertTrueEventually(new AssertTask(){
      @Override public void run() throws Exception {
        assertEquals(numberOfMessages,instance1.getQueue(outQueueName).size());
        assertTrue(instance1.getQueue(inQueueName).isEmpty());
      }
    }
);
  }
  finally {
    moveMessage1.active=false;
  }
}
