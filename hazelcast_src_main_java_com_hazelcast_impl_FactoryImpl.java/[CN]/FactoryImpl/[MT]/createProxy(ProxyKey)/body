{
  node.clusterManager.checkServiceThread();
  boolean created=false;
  HazelcastInstanceAwareInstance proxy=proxies.get(proxyKey);
  if (proxy == null) {
    created=true;
    String name=proxyKey.name;
    if (name.startsWith(Prefix.QUEUE)) {
      proxy=new QProxyImpl(name,this);
    }
 else     if (name.startsWith(Prefix.TOPIC)) {
      proxy=new TopicProxyImpl(name,this);
    }
 else     if (name.startsWith(Prefix.MAP)) {
      proxy=new MProxyImpl(name,this);
      node.concurrentMapManager.getOrCreateMap(name);
    }
 else     if (name.startsWith(Prefix.AS_LIST)) {
      proxy=new ListProxyImpl(name,this);
    }
 else     if (name.startsWith(Prefix.MULTIMAP)) {
      proxy=new MultiMapProxyImpl(name,this);
    }
 else     if (name.startsWith(Prefix.SET)) {
      proxy=new CollectionProxyImpl(name,this);
    }
 else     if (name.startsWith(Prefix.ATOMIC_NUMBER)) {
      proxy=new AtomicNumberProxyImpl(name,this);
    }
 else     if (name.startsWith(Prefix.IDGEN)) {
      proxy=new IdGeneratorProxy(name,this);
    }
 else     if (name.startsWith(Prefix.SEMAPHORE)) {
      proxy=new SemaphoreProxyImpl(name,this);
    }
 else     if (name.startsWith(Prefix.COUNT_DOWN_LATCH)) {
      proxy=new CountDownLatchProxyImpl(name,this);
    }
 else     if (name.equals("lock")) {
      proxy=new LockProxy(this,proxyKey.key);
    }
    final HazelcastInstanceAwareInstance anotherProxy=proxies.putIfAbsent(proxyKey,proxy);
    if (anotherProxy != null) {
      created=false;
      proxy=anotherProxy;
    }
    if (proxyKey.key == null) {
      proxiesByName.put(proxyKey.name,proxy);
    }
  }
  if (created) {
    fireInstanceCreateEvent(proxy);
  }
  return proxy;
}
