{
  if (proxy instanceof MProxy) {
    MProxy mProxy=(MProxy)proxy;
    CMap cmap=node.concurrentMapManager.getMap(mProxy.getLongName());
    if (cmap == null) {
      logger.log(Level.WARNING,"CMap[" + mProxy.getLongName() + "] has not been created yet! Initialization attempt failed!");
      return;
    }
    if (!cmap.isMapForQueue() && cmap.notInitialized()) {
      while (!node.concurrentMapManager.partitionServiceImpl.allPartitionsOwned()) {
        try {
          Thread.sleep(250);
          logger.log(Level.FINEST,"Waiting for all partitions to be owned...");
        }
 catch (        InterruptedException e) {
          return;
        }
      }
synchronized (cmap.getInitLock()) {
        if (cmap.notInitialized()) {
          final MapStoreConfig mapStoreConfig=cmap.getMapConfig().getMapStoreConfig();
          if (mapStoreConfig != null && mapStoreConfig.isEnabled()) {
            cmap.setInitState(InitializationState.INITIALIZING);
            try {
              ExecutorService es=getExecutorService();
              final Set<Member> members=new HashSet<Member>(getCluster().getMembers());
              members.remove(node.localMember);
              final MultiTask task=new MultiTask(new InitializeMap(mProxy.getName()),members);
              es.execute(task);
              if (cmap.loader != null) {
                Set keys=cmap.loader.loadAllKeys();
                if (keys != null) {
                  int count=0;
                  Queue<Set> chunks=new LinkedList<Set>();
                  Set ownedKeys=new HashSet();
                  PartitionService partitionService=getPartitionService();
                  for (                  Object key : keys) {
                    Member owner=partitionService.getPartition(key).getOwner();
                    if (owner == null || owner.localMember()) {
                      ownedKeys.add(key);
                      count++;
                      if (ownedKeys.size() >= node.groupProperties.MAP_LOAD_CHUNK_SIZE.getInteger()) {
                        chunks.add(ownedKeys);
                        ownedKeys=new HashSet();
                      }
                    }
                  }
                  chunks.add(ownedKeys);
                  loadChunks(mProxy,cmap,chunks);
                  logger.log(Level.INFO,node.address + "[" + mProxy.getName()+ "] loaded "+ count+ " in total.");
                }
              }
              task.get();
            }
 catch (            Throwable e) {
              if (node.isActive()) {
                logger.log(Level.SEVERE,e.getMessage(),e);
              }
            }
          }
        }
        cmap.setInitState(InitializationState.INITIALIZED);
      }
    }
  }
}
