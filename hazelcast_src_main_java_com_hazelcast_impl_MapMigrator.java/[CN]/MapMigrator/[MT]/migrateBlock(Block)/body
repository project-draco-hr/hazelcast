{
  if (!thisAddress.equals(block.getOwner())) {
    throw new RuntimeException();
  }
  if (block.getMigrationAddress() == null) {
    throw new RuntimeException();
  }
  if (block.getOwner().equals(block.getMigrationAddress())) {
    throw new RuntimeException();
  }
  Block blockReal=blocks[block.getBlockId()];
  blockReal.setOwner(block.getOwner());
  blockReal.setMigrationAddress(block.getMigrationAddress());
  logger.log(Level.FINEST,"migrate block " + block);
  if (!node.isActive() || node.factory.restarted) {
    return;
  }
  if (concurrentMapManager.isSuperClient()) {
    return;
  }
  blockMigrating=block;
  List<Record> lsRecordsToMigrate=new ArrayList<Record>(1000);
  Collection<CMap> cmaps=concurrentMapManager.maps.values();
  for (  final CMap cmap : cmaps) {
    if (cmap.locallyOwnedMap != null) {
      cmap.locallyOwnedMap.reset();
    }
    final Object[] records=cmap.ownedRecords.toArray();
    for (    Object recObj : records) {
      final Record rec=(Record)recObj;
      if (rec.isActive()) {
        if (rec.getKey() == null || rec.getKey().size() == 0) {
          throw new RuntimeException("Record.key is null or empty " + rec.getKey());
        }
        if (rec.getBlockId() == block.getBlockId()) {
          lsRecordsToMigrate.add(rec);
          cmap.markAsRemoved(rec);
        }
      }
    }
  }
  final CountDownLatch latch=new CountDownLatch(lsRecordsToMigrate.size());
  for (  final Record rec : lsRecordsToMigrate) {
    final CMap cmap=concurrentMapManager.getMap(rec.getName());
    node.executorManager.executeMigrationTask(new FallThroughRunnable(){
      public void doRun(){
        try {
          concurrentMapManager.migrateRecord(cmap,rec);
        }
  finally {
          latch.countDown();
        }
      }
    }
);
  }
  node.executorManager.executeMigrationTask(new FallThroughRunnable(){
    public void doRun(){
      try {
        latch.await(10,TimeUnit.SECONDS);
        block.setOwner(block.getMigrationAddress());
        block.setMigrationAddress(null);
        concurrentMapManager.enqueueAndReturn(new Processable(){
          public void process(){
            Block blockReal=blocks[block.getBlockId()];
            blockReal.setOwner(block.getOwner());
            blockReal.setMigrationAddress(null);
          }
        }
);
        for (        MemberImpl member : concurrentMapManager.getMembers()) {
          if (!member.localMember()) {
            boolean sent=false;
            while (!sent) {
              sent=concurrentMapManager.sendBlockInfo(block,member.getAddress());
              Thread.sleep(1000);
            }
          }
        }
      }
 catch (      InterruptedException ignored) {
      }
    }
  }
);
}
