{
  final long now=Clock.currentTimeMillis();
  final MapServiceContext mapServiceContext=this.mapServiceContext;
  final NodeEngine nodeEngine=mapServiceContext.getNodeEngine();
  final ClusterService clusterService=nodeEngine.getClusterService();
  final InternalPartitionService partitionService=nodeEngine.getPartitionService();
  final Address thisAddress=clusterService.getThisAddress();
  final int partitionCount=partitionService.getPartitionCount();
  Map<Integer,Integer> partitionToEntryCountHolder=Collections.emptyMap();
  List<DelayedEntry> entries=Collections.emptyList();
  boolean createLazy=true;
  for (int partitionId=0; partitionId < partitionCount; partitionId++) {
    final InternalPartition partition=partitionService.getPartition(partitionId);
    final Address owner=partition.getOwnerOrNull();
    final RecordStore recordStore=getRecordStoreOrNull(mapName,partitionId);
    if (owner == null || recordStore == null) {
      continue;
    }
    final WriteBehindQueue<DelayedEntry> queue=getWriteBehindQueue(recordStore);
    final List<DelayedEntry> delayedEntries=filterItemsLessThanOrEqualToTime(queue,now);
    if (delayedEntries.isEmpty()) {
      continue;
    }
    if (!owner.equals(thisAddress)) {
      if (now < lastRunTime + backupRunIntervalTime) {
        doInBackup(queue,delayedEntries,partitionId);
      }
      continue;
    }
    if (createLazy) {
      partitionToEntryCountHolder=new HashMap<Integer,Integer>();
      entries=new ArrayList<DelayedEntry>();
      createLazy=false;
    }
    partitionToEntryCountHolder.put(partitionId,delayedEntries.size());
    entries.addAll(delayedEntries);
  }
  if (!entries.isEmpty()) {
    final Map<Integer,List<DelayedEntry>> failsPerPartition=writeBehindProcessor.process(entries);
    removeProcessedEntries(mapName,partitionToEntryCountHolder);
    addFailsToQueue(mapName,failsPerPartition);
    lastRunTime=now;
  }
}
