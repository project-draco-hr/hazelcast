{
  final long now=System.currentTimeMillis();
  long dirtyAge=(now - lastCleanup);
  boolean shouldRun=forced || (store != null && dirty && dirtyAge >= writeDelayMillis) || (dirtyAge > cleanupDelayMillis);
  if (shouldRun && cleanupActive.compareAndSet(false,true)) {
    lastCleanup=now;
    try {
      if (nearCache != null) {
        nearCache.evict(now,false);
      }
      dirty=false;
      final Set<Record> recordsDirty=new HashSet<Record>();
      final Set<Record> recordsUnknown=new HashSet<Record>();
      final Set<Record> recordsToPurge=new HashSet<Record>();
      final Set<Record> recordsToEvict=new HashSet<Record>();
      final Set<Record> sortedRecords=new TreeSet<Record>(new ComparatorWrapper(evictionComparator));
      final Collection<Record> records=mapRecords.values();
      final boolean overCapacity=maxSizePolicy != null && maxSizePolicy.overCapacity();
      final boolean evictionAware=evictionComparator != null && overCapacity;
      int recordsStillOwned=0;
      int backupPurgeCount=0;
      PartitionManager partitionManager=concurrentMapManager.partitionManager;
      for (      Record record : records) {
        PartitionInfo partition=partitionManager.getPartition(record.getBlockId());
        Address owner=partition.getOwner();
        boolean owned=(owner != null && thisAddress.equals(owner));
        boolean ownedOrBackup=partition.isOwnerOrBackup(thisAddress,backupCount);
        if (owner != null && !partitionManager.isPartitionMigrating(partition.getPartitionId())) {
          if (owned) {
            if (store != null && writeDelayMillis > 0 && record.isDirty()) {
              if (now > record.getWriteTime()) {
                recordsDirty.add(record);
                record.setDirty(false);
              }
 else {
                dirty=true;
              }
            }
 else             if (shouldPurgeRecord(record,now)) {
              recordsToPurge.add(record);
            }
 else             if (record.isActive() && !record.isValid(now)) {
              recordsToEvict.add(record);
            }
 else             if (evictionAware && record.isActive() && record.isEvictable()) {
              sortedRecords.add(record);
              recordsStillOwned++;
            }
          }
 else           if (ownedOrBackup) {
            if (shouldPurgeRecord(record,now)) {
              recordsToPurge.add(record);
              backupPurgeCount++;
            }
          }
 else {
            recordsUnknown.add(record);
          }
        }
      }
      if (evictionAware && (forced || overCapacity)) {
        int numberOfRecordsToEvict=(int)(recordsStillOwned * evictionRate);
        int evictedCount=0;
        for (        Record record : sortedRecords) {
          if (record.isActive() && record.isEvictable()) {
            recordsToEvict.add(record);
            if (++evictedCount >= numberOfRecordsToEvict) {
              break;
            }
          }
        }
      }
      Level levelLog=(concurrentMapManager.LOG_STATE) ? Level.INFO : Level.FINEST;
      logger.log(levelLog,name + " Cleanup " + ", dirty:"+ recordsDirty.size()+ ", purge:"+ recordsToPurge.size()+ ", evict:"+ recordsToEvict.size()+ ", unknown:"+ recordsUnknown.size()+ ", stillOwned:"+ recordsStillOwned+ ", backupPurge:"+ backupPurgeCount);
      executeStoreUpdate(recordsDirty);
      executeEviction(recordsToEvict);
      executePurge(recordsToPurge);
      executePurgeUnknowns(recordsUnknown);
    }
  finally {
      cleanupActive.set(false);
    }
    return true;
  }
 else {
    return false;
  }
}
