{
  long now=System.currentTimeMillis();
  if (ownedRecords.size() >= maxSize) {
    startEviction(true);
  }
  if (req.value == null) {
    req.value=new Data();
  }
  Record record=getRecord(req.key);
  if (req.operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
    if (record != null && record.isActive() && record.isValid(now) && record.getValue() != null) {
      req.clearForResponse();
      req.response=record.getValue();
      return;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_NOT_NULL) {
    if (record == null || !record.isActive() || !record.isValid(now) || record.getValue() == null) {
      return;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_SAME) {
    if (record == null || !record.isActive() || !record.isValid(now)) {
      req.response=Boolean.FALSE;
      return;
    }
    MultiData multiData=(MultiData)toObject(req.value);
    if (multiData == null || multiData.size() != 2) {
      throw new RuntimeException("Illegal replaceIfSame argument: " + multiData);
    }
    Data expectedOldValue=multiData.getData(0);
    Data newValue=multiData.getData(1);
    req.value=newValue;
    if (!record.getValue().equals(expectedOldValue)) {
      req.response=Boolean.FALSE;
      return;
    }
  }
  req.value.hash=(int)req.longValue;
  Data oldValue=null;
  boolean created=false;
  if (record == null) {
    record=createNewRecord(req.key,req.value);
    created=true;
  }
 else {
    markAsActive(record);
    oldValue=(record.isValid(now)) ? record.getValue() : null;
    record.setValue(req.value);
    record.incrementVersion();
    touch(record);
    record.setLastUpdated();
  }
  if (req.ttl > 0) {
    record.setExpirationTime(req.ttl);
    ttlPerRecord=true;
  }
  markAsOwned(record);
  if (oldValue == null) {
    concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_ADDED,record);
  }
 else {
    fireInvalidation(record);
    concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_UPDATED,record);
  }
  if (req.txnId != -1) {
    unlock(record);
  }
  record.setIndexes(req.indexes,req.indexTypes);
  updateIndexes(record);
  markAsDirty(record);
  req.clearForResponse();
  req.version=record.getVersion();
  req.longValue=record.getCopyCount();
  if (req.operation == CONCURRENT_MAP_REPLACE_IF_SAME) {
    req.response=Boolean.TRUE;
  }
 else {
    req.response=oldValue;
  }
}
