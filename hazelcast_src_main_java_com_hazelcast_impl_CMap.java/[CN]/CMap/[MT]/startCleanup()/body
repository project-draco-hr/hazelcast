{
  final long now=System.currentTimeMillis();
  if (((now - lastRemoveTime) > removeDelayMillis)) {
    lastRemoveTime=now;
    final Map<Data,Data> entriesToStore=new HashMap<Data,Data>();
    final Collection<Data> keysToDelete=new HashSet<Data>();
    final Set<Record> recordsToPurge=new HashSet<Record>();
    final Set<Record> recordsToEvict=new HashSet<Record>();
    final Set<Record> sortedRecords=new TreeSet<Record>(new LRUComparator());
    final Collection<Record> ownedRecords=mapIndexService.getOwnedRecords();
    for (    Record record : ownedRecords) {
      if (store != null && record.isDirty()) {
        if (record.getWriteTime() > now) {
          if (record.getValue() != null) {
            entriesToStore.put(record.getKey(),record.getValue());
          }
 else {
            keysToDelete.add(record.getKey());
          }
          record.setDirty(false);
        }
      }
 else       if (shouldPurgeRecord(record,now)) {
        recordsToPurge.add(record);
      }
 else       if (record.isActive() && !record.isValid(now)) {
        recordsToEvict.add(record);
      }
 else       if (record.isActive() && record.isEvictable()) {
        sortedRecords.add(record);
      }
    }
    int recordsLeft=ownedRecords.size() - (keysToDelete.size() + recordsToEvict.size() + recordsToPurge.size());
    if (evictionPolicy != SortedHashMap.OrderingType.NONE && maxSize > 0 && maxSize < recordsLeft) {
      int numberOfRecordsToEvict=(int)(recordsLeft * evictionRate);
      int evictedCount=0;
      for (      Record record : sortedRecords) {
        if (record.isActive() && record.isEvictable()) {
          recordsToEvict.add(record);
          if (++evictedCount >= numberOfRecordsToEvict) {
            break;
          }
        }
      }
    }
    System.out.println("Cleanup " + ", store:" + entriesToStore.size() + ", delete:"+ keysToDelete.size()+ ", purge:"+ recordsToPurge.size()+ ", evict:"+ recordsToEvict.size());
    executeStoreUpdate(entriesToStore,keysToDelete);
    executeEviction(recordsToEvict);
    if (recordsToPurge.size() > 0) {
      concurrentMapManager.enqueueAndReturn(new Processable(){
        public void process(){
          for (          Record recordToPurge : recordsToPurge) {
            if (shouldPurgeRecord(recordToPurge,now)) {
              removeAndPurgeRecord(recordToPurge);
            }
          }
        }
      }
);
    }
  }
}
