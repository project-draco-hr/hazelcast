{
  final long now=System.currentTimeMillis();
  if (locallyOwnedMap != null) {
    locallyOwnedMap.evict(now);
  }
  if (mapNearCache != null) {
    mapNearCache.evict(now,false);
  }
  final Set<Record> recordsDirty=new HashSet<Record>();
  final Set<Record> recordsUnknown=new HashSet<Record>();
  final Set<Record> recordsToPurge=new HashSet<Record>();
  final Set<Record> recordsToEvict=new HashSet<Record>();
  final Set<Record> sortedRecords=new TreeSet<Record>(evictionComparator);
  final Collection<Record> records=mapRecords.values();
  final int clusterMemberSize=node.getClusterImpl().getMembers().size();
  final int memberCount=(clusterMemberSize == 0) ? 1 : clusterMemberSize;
  final int maxSizePerJVM=maxSize / memberCount;
  final boolean evictionAware=evictionComparator != null && maxSizePerJVM > 0;
  final PartitionServiceImpl partitionService=concurrentMapManager.partitionManager.partitionServiceImpl;
  int recordsStillOwned=0;
  int backupPurgeCount=0;
  for (  Record record : records) {
    PartitionServiceImpl.PartitionProxy partition=partitionService.getPartition(record.getBlockId());
    Member owner=partition.getOwner();
    if (owner != null && !partition.isMigrating()) {
      boolean owned=owner.localMember();
      if (owned) {
        if (store != null && record.isDirty()) {
          if (now > record.getWriteTime()) {
            recordsDirty.add(record);
          }
        }
 else         if (shouldPurgeRecord(record,now)) {
          recordsToPurge.add(record);
        }
 else         if (record.isActive() && !record.isValid(now)) {
          recordsToEvict.add(record);
        }
 else         if (evictionAware && record.isActive() && record.isEvictable()) {
          sortedRecords.add(record);
          recordsStillOwned++;
        }
 else {
          recordsStillOwned++;
        }
      }
 else {
        Member ownerEventual=partition.getEventualOwner();
        boolean backup=false;
        if (ownerEventual != null && owner != null && !owner.localMember()) {
          int distance=node.getClusterImpl().getDistanceFrom(ownerEventual);
          backup=(distance != -1 && distance <= getBackupCount());
        }
        if (backup) {
          if (shouldPurgeRecord(record,now)) {
            recordsToPurge.add(record);
            backupPurgeCount++;
          }
        }
 else {
          recordsUnknown.add(record);
        }
      }
    }
  }
  if (evictionAware && maxSizePerJVM < recordsStillOwned) {
    int numberOfRecordsToEvict=(int)(recordsStillOwned * evictionRate);
    int evictedCount=0;
    for (    Record record : sortedRecords) {
      if (record.isActive() && record.isEvictable()) {
        recordsToEvict.add(record);
        if (++evictedCount >= numberOfRecordsToEvict) {
          break;
        }
      }
    }
  }
  Level levelLog=(concurrentMapManager.LOG_STATE) ? Level.INFO : Level.FINEST;
  logger.log(levelLog,name + " Cleanup " + ", dirty:"+ recordsDirty.size()+ ", purge:"+ recordsToPurge.size()+ ", evict:"+ recordsToEvict.size()+ ", unknown:"+ recordsUnknown.size()+ ", stillOwned:"+ recordsStillOwned+ ", backupPurge:"+ backupPurgeCount);
  executeStoreUpdate(recordsDirty);
  executeEviction(recordsToEvict);
  executePurge(recordsToPurge);
  executePurgeUnknowns(recordsUnknown);
}
