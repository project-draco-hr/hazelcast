{
  long now=System.currentTimeMillis();
  int ownedEntryCount=0;
  int backupEntryCount=0;
  int markedAsRemovedEntryCount=0;
  int ownedEntryMemoryCost=0;
  int backupEntryMemoryCost=0;
  int markedAsRemovedMemoryCost=0;
  int hits=0;
  int lockedEntryCount=0;
  int lockWaitCount=0;
  ClusterImpl clusterImpl=node.getClusterImpl();
  final Collection<Record> records=mapRecords.values();
  final PartitionServiceImpl partitionService=concurrentMapManager.partitionManager.partitionServiceImpl;
  for (  Record record : records) {
    if (!record.isActive() || !record.isValid(now)) {
      markedAsRemovedEntryCount++;
      markedAsRemovedMemoryCost+=record.getCost();
    }
 else {
      PartitionServiceImpl.PartitionProxy partition=partitionService.getPartition(record.getBlockId());
      Member owner=partition.getOwner();
      if (owner != null && !partition.isMigrating()) {
        boolean owned=owner.localMember();
        if (owned) {
          ownedEntryCount+=record.valueCount();
          ownedEntryMemoryCost+=record.getCost();
          localMapStats.setLastAccessTime(record.getLastAccessTime());
          localMapStats.setLastUpdateTime(record.getLastUpdateTime());
          hits+=record.getHits();
          if (record.isLocked()) {
            lockedEntryCount++;
            lockWaitCount+=record.getScheduledActionCount();
          }
        }
 else {
          Member ownerEventual=partition.getEventualOwner();
          boolean backup=false;
          if (ownerEventual != null && !owner.localMember()) {
            int distance=node.getClusterImpl().getDistanceFrom(ownerEventual);
            backup=(distance != -1 && distance <= getBackupCount());
          }
          if (backup && !shouldPurgeRecord(record,now)) {
            backupEntryCount+=record.valueCount();
            backupEntryMemoryCost+=record.getCost();
          }
 else {
            markedAsRemovedEntryCount++;
            markedAsRemovedMemoryCost+=record.getCost();
          }
        }
      }
    }
  }
  localMapStats.setMarkedAsRemovedEntryCount(markedAsRemovedEntryCount);
  localMapStats.setMarkedAsRemovedMemoryCost(markedAsRemovedMemoryCost);
  localMapStats.setLockWaitCount(lockWaitCount);
  localMapStats.setLockedEntryCount(lockedEntryCount);
  localMapStats.setHits(hits);
  localMapStats.setOwnedEntryCount(ownedEntryCount);
  localMapStats.setBackupEntryCount(backupEntryCount);
  localMapStats.setOwnedEntryMemoryCost(ownedEntryMemoryCost);
  localMapStats.setBackupEntryMemoryCost(backupEntryMemoryCost);
  localMapStats.setLastEvictionTime(clusterImpl.getClusterTimeFor(lastEvictionTime));
  localMapStats.setCreationTime(clusterImpl.getClusterTimeFor(creationTime));
}
