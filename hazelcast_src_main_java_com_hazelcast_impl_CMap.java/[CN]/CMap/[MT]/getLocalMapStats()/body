{
  long now=System.currentTimeMillis();
  int ownedEntryCount=0;
  int backupEntryCount=0;
  int removedEntryCount=0;
  int ownedEntryMemoryCost=0;
  int backupEntryMemoryCost=0;
  int markedAsRemovedMemoryCost=0;
  int hits=0;
  int lockedEntryCount=0;
  int lockWaitCount=0;
  PartitionServiceImpl partitionService=concurrentMapManager.partitionManager.partitionServiceImpl;
  ClusterImpl clusterImpl=node.getClusterImpl();
  LocalMapStatsImpl localMapStats=new LocalMapStatsImpl();
  Map<Data,Record> allRecords=new HashMap<Data,Record>();
  allRecords.putAll(mapOwnedRecords);
  allRecords.putAll(mapBackupRecords);
  for (  Record record : allRecords.values()) {
    if (isBackup(record,partitionService,now)) {
      backupEntryCount+=record.valueCount();
      backupEntryMemoryCost+=record.getCost();
    }
 else     if (isOwned(record,partitionService,now)) {
      ownedEntryCount+=record.valueCount();
      ownedEntryMemoryCost+=record.getCost();
      localMapStats.setLastAccessTime(clusterImpl.getClusterTimeFor(record.getLastAccessTime()));
      localMapStats.setLastUpdateTime(clusterImpl.getClusterTimeFor(record.getLastUpdateTime()));
      hits+=record.getHits();
      if (record.isLocked()) {
        lockedEntryCount++;
        lockWaitCount+=record.getScheduledActionCount();
      }
    }
  }
  localMapStats.setMarkedAsRemovedEntryCount(removedEntryCount);
  localMapStats.setMarkedAsRemovedMemoryCost(markedAsRemovedMemoryCost);
  localMapStats.setLockWaitCount(lockWaitCount);
  localMapStats.setLockedEntryCount(lockedEntryCount);
  localMapStats.setHits(hits);
  localMapStats.setOwnedEntryCount(ownedEntryCount);
  localMapStats.setBackupEntryCount(backupEntryCount);
  localMapStats.setOwnedEntryMemoryCost(ownedEntryMemoryCost);
  localMapStats.setBackupEntryMemoryCost(backupEntryMemoryCost);
  localMapStats.setLastEvictionTime(clusterImpl.getClusterTimeFor(lastEvictionTime));
  localMapStats.setCreationTime(clusterImpl.getClusterTimeFor(creationTime));
  return localMapStats;
}
