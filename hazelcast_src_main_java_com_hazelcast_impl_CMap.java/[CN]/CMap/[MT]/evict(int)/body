{
  final long now=System.currentTimeMillis();
  final Collection<Record> records=mapRecords.values();
  Comparator<MapEntry> comparator=evictionComparator;
  if (comparator == null) {
    comparator=new ComparatorWrapper(LRU_COMPARATOR);
  }
  final PartitionServiceImpl partitionService=concurrentMapManager.partitionServiceImpl;
  final PartitionManager partitionManager=concurrentMapManager.partitionManager;
  final Set<Record> sortedRecords=new TreeSet<Record>(new ComparatorWrapper(comparator));
  final Set<Record> recordsToEvict=new HashSet<Record>();
  for (  Record record : records) {
    PartitionServiceImpl.PartitionProxy partition=partitionService.getPartition(record.getBlockId());
    Member owner=partition.getOwner();
    if (owner != null && !partitionManager.isOwnedPartitionMigrating(partition.getPartitionId())) {
      boolean owned=owner.localMember();
      if (owned) {
        if (store != null && writeDelayMillis > 0 && record.isDirty()) {
        }
 else         if (shouldPurgeRecord(record,now)) {
        }
 else         if (record.isActive() && !record.isValid(now)) {
          recordsToEvict.add(record);
        }
 else         if (record.isActive() && record.isEvictable()) {
          sortedRecords.add(record);
        }
      }
    }
  }
  int numberOfRecordsToEvict=sortedRecords.size() * percentage / 100;
  int evictedCount=0;
  for (  Record record : sortedRecords) {
    recordsToEvict.add(record);
    if (++evictedCount >= numberOfRecordsToEvict) {
      break;
    }
  }
  executeEviction(recordsToEvict);
}
