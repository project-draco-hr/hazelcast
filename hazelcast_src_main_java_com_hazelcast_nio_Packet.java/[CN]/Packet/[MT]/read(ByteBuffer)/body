{
  while (!sizeRead && bb.hasRemaining() && bbSizes.hasRemaining()) {
    IOUtil.copyToHeapBuffer(bb,bbSizes);
  }
  if (!sizeRead && !bbSizes.hasRemaining()) {
    sizeRead=true;
    bbSizes.flip();
    bbHeader.limit(bbSizes.getInt());
    int keySize=bbSizes.getInt();
    int valueSize=bbSizes.getInt();
    if (keySize > 0)     key=new DataHolder(keySize);
    if (valueSize > 0)     value=new DataHolder(valueSize);
    if (bbHeader.limit() == 0) {
      throw new RuntimeException("read.bbHeader size cannot be 0");
    }
    byte packetVersion=bbSizes.get();
    if (packetVersion != PACKET_VERSION) {
      String msg="Packet versions are not the same. Expected " + PACKET_VERSION + " Found: "+ packetVersion;
      logger.log(Level.WARNING,msg);
      throw new RuntimeException(msg);
    }
  }
  if (sizeRead) {
    while (bb.hasRemaining() && bbHeader.hasRemaining()) {
      IOUtil.copyToHeapBuffer(bb,bbHeader);
    }
    while (key != null && bb.hasRemaining() && key.shouldRead()) {
      key.read(bb);
    }
    while (getValueData() != null && bb.hasRemaining() && value.shouldRead()) {
      value.read(bb);
    }
  }
  if (sizeRead && !bbHeader.hasRemaining() && (key == null || !key.shouldRead())&& (value == null || !value.shouldRead())) {
    sizeRead=false;
    if (key != null)     key.postRead();
    if (value != null)     value.postRead();
    return true;
  }
  return false;
}
