{
  final Map<String,String> privatePublicPairs=new LinkedHashMap<String,String>();
  if (node == null)   return privatePublicPairs;
  for (  org.w3c.dom.Node node : new AbstractXmlConfigHelper.IterableNodeList(this.node.getChildNodes())) {
    String nodeName=cleanNodeName(node.getNodeName());
    if (!"item".equals(nodeName))     continue;
    final NodeHolder nodeHolder=new NodeHolder(node);
    final String state=getState(nodeHolder);
    final String privateIp=getIp("privateipaddress",nodeHolder);
    final String publicIp=getIp("ipaddress",nodeHolder);
    final String instanceName=getInstanceName(nodeHolder);
    if (privateIp != null && publicIp != null) {
      if (!acceptState(state)) {
        logger.finest(format("Ignoring EC2 instance [%s][%s] reason: the instance is not running but %s",instanceName,privateIp,state));
      }
 else       if (!acceptTag(awsConfig,node)) {
        logger.finest(format("Ignoring EC2 instance [%s][%s] reason: tag-key/tag-value don't match",instanceName,privateIp));
      }
 else       if (!acceptGroupName(awsConfig,node)) {
        logger.finest(format("Ignoring EC2 instance [%s][%s] reason: security-group-name doesn't match",instanceName,privateIp));
      }
 else {
        privatePublicPairs.put(privateIp,publicIp);
        logger.finest(format("Accepting EC2 instance [%s][%s]",instanceName,privateIp));
      }
    }
  }
  return privatePublicPairs;
}
