{
  final String instanceName=properties.getProperty(INSTANCE_NAME);
  final String configLocation=properties.getProperty(CONFIG_LOCATION);
  final String useClientProp=properties.getProperty(USE_CLIENT);
  final String clientConfigLocation=properties.getProperty(CLIENT_CONFIG_LOCATION);
  final boolean useClient=!isEmpty(useClientProp) && Boolean.parseBoolean(useClientProp);
  URL configUrl=null;
  if (useClient && !isEmpty(clientConfigLocation)) {
    configUrl=getConfigURL(filterConfig,clientConfigLocation);
  }
 else   if (!isEmpty(configLocation)) {
    configUrl=getConfigURL(filterConfig,configLocation);
  }
  if (useClient) {
    logger.warning("Creating HazelcastClient for session replication, make sure this client has access to an already running cluster...");
    ClientConfig clientConfig;
    if (configUrl == null) {
      clientConfig=new ClientConfig();
      clientConfig.setConnectionAttemptLimit(3);
    }
 else {
      try {
        clientConfig=new XmlClientConfigBuilder(configUrl).build();
      }
 catch (      IOException e) {
        throw new ServletException(e);
      }
    }
    return HazelcastClient.newHazelcastClient(clientConfig);
  }
  Config config;
  if (configUrl == null) {
    config=new XmlConfigBuilder().build();
  }
 else {
    try {
      config=new UrlXmlConfig(configUrl);
    }
 catch (    IOException e) {
      throw new ServletException(e);
    }
  }
  if (!isEmpty(instanceName)) {
    if (logger.isLoggable(Level.INFO)) {
      logger.info(format("Getting an existing or creating a new HazelcastInstance for session replication, using name '%s'",instanceName));
    }
    config.setInstanceName(instanceName);
    return Hazelcast.getOrCreateHazelcastInstance(config);
  }
 else {
    logger.info("Creating a new HazelcastInstance for session replication");
    return Hazelcast.newHazelcastInstance(config);
  }
}
