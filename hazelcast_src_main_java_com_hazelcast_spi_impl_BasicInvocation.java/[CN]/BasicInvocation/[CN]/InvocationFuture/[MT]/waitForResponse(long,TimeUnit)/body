{
  if (response != null && response != WAIT_RESPONSE) {
    return response;
  }
  long timeoutMs=unit.toMillis(time);
  if (timeoutMs < 0)   timeoutMs=0;
  final long maxCallTimeout=callTimeout * 2 > 0 ? callTimeout * 2 : Long.MAX_VALUE;
  final boolean longPolling=timeoutMs > maxCallTimeout;
  int pollCount=0;
  while (timeoutMs >= 0) {
    final long pollTimeoutMs=Math.min(maxCallTimeout,timeoutMs);
    final long startMs=Clock.currentTimeMillis();
    long lastPollTime=0;
    pollCount++;
    try {
      if (pollTimeoutMs > 0) {
synchronized (this) {
          if (response == null || response == WAIT_RESPONSE) {
            this.wait(pollTimeoutMs);
          }
        }
      }
      lastPollTime=Clock.currentTimeMillis() - startMs;
      timeoutMs=decrementTimeout(timeoutMs,lastPollTime);
      if (response != null) {
        if (response == WAIT_RESPONSE) {
          continue;
        }
        if (response != INTERRUPTED_RESPONSE && interrupted) {
          Thread.currentThread().interrupt();
        }
        return response;
      }
    }
 catch (    InterruptedException e) {
      interrupted=true;
    }
    if (!interrupted && longPolling) {
      final Address target=getTarget();
      if (nodeEngine.getThisAddress().equals(target)) {
        continue;
      }
      logger.warning("No response for " + lastPollTime + " ms. "+ toString());
      boolean executing=isOperationExecuting(target);
      if (!executing) {
        if (response != null) {
          continue;
        }
        return newOperationTimeoutException(pollCount,pollTimeoutMs);
      }
    }
  }
  return TIMEOUT_RESPONSE;
}
