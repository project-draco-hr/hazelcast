{
  float ratio=RANGE_CHECK_RATIO;
  int avgPartitionPerGroup=partitionCount / groups.size();
  int replicaCount=Math.min(groups.size(),InternalPartition.MAX_REPLICA_COUNT);
  Set<Address> set=new HashSet<Address>();
  for (int partitionId=0; partitionId < partitionCount; partitionId++) {
    Address[] replicas=state[partitionId];
    for (int i=0; i < replicaCount; i++) {
      Address owner=replicas[i];
      if (owner == null) {
        logger.warning("Partition-Arrangement-Test: Owner is null !!! => partition: " + partitionId + " replica: "+ i);
        return TestResult.FAIL;
      }
      if (set.contains(owner)) {
        logger.warning("Partition-Arrangement-Test: " + owner + " has owned multiple replicas of partition: "+ partitionId+ " replica: "+ i);
        return TestResult.FAIL;
      }
      set.add(owner);
    }
    set.clear();
  }
  for (  NodeGroup group : groups) {
    for (int i=0; i < replicaCount; i++) {
      int partitionCountOfGroup=group.getPartitionCount(i);
      if (Math.abs(partitionCountOfGroup - avgPartitionPerGroup) <= MIN_AVG_OWNER_DIFF) {
        continue;
      }
      if ((partitionCountOfGroup < avgPartitionPerGroup / ratio) || (partitionCountOfGroup > avgPartitionPerGroup * ratio)) {
        if (logger.isFinestEnabled()) {
          logger.finest("Replica: " + i + ", PartitionCount: "+ partitionCountOfGroup+ ", AvgPartitionCount: "+ avgPartitionPerGroup);
        }
        return TestResult.RETRY;
      }
    }
  }
  return TestResult.PASS;
}
