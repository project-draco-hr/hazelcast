{
  Config config=new Config();
  final HazelcastInstance h=Hazelcast.newHazelcastInstance(config);
  final AtomicInteger counter1=new AtomicInteger(0);
  final AtomicInteger counterOfFails=new AtomicInteger(0);
  final AtomicReference<Integer> last=new AtomicReference<Integer>(0);
  HazelcastClient client=newHazelcastClient(h);
  client.getMap("testUpdateEventOrder").addEntryListener(new EntryListener<Object,Object>(){
    public void entryAdded(    EntryEvent<Object,Object> event){
      this.entryUpdated(event);
    }
    public void entryRemoved(    EntryEvent<Object,Object> objectObjectEntryEvent){
    }
    public void entryUpdated(    EntryEvent<Object,Object> event){
      if ((Integer)event.getValue() - last.get() != 1) {
        System.out.println(Thread.currentThread() + ": " + last.get()+ "::"+ event.getValue());
        counterOfFails.incrementAndGet();
      }
      last.set((Integer)event.getValue());
    }
    public void entryEvicted(    EntryEvent<Object,Object> objectObjectEntryEvent){
    }
  }
,true);
  ExecutorService ex=Executors.newFixedThreadPool(2);
  int count=10000;
  final CountDownLatch latch=new CountDownLatch(count);
  for (int i=0; i < count; i++) {
    ex.execute(new Runnable(){
      public void run(){
synchronized (latch) {
          h.getMap("testUpdateEventOrder").put("key",counter1.incrementAndGet());
          latch.countDown();
        }
      }
    }
);
  }
  latch.await();
  System.out.println(counterOfFails.get() + " out of " + count);
}
