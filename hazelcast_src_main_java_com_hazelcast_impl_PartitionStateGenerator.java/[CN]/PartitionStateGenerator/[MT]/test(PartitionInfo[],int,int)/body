{
  final int replicaCount=Math.min(memberCount,PartitionInfo.MAX_REPLICA_COUNT);
  final int avgPartitionPerNode=partitionCount / memberCount;
  Set<Address> set=new HashSet<Address>();
  Map<Address,List[]> map=new HashMap<Address,List[]>();
  for (  PartitionInfo p : state) {
    for (int i=0; i < replicaCount; i++) {
      Address owner=p.getReplicaAddress(i);
      if (set.contains(owner)) {
        logger.log(Level.SEVERE,owner + " has owned multiple replicas of partition: " + p.getPartitionId());
        return false;
      }
      set.add(owner);
      List[] ll=map.get(p.getReplicaAddress(i));
      if (ll == null) {
        ll=new List[replicaCount];
        for (int j=0; j < replicaCount; j++) {
          ll[j]=new ArrayList<Integer>();
        }
        map.put(owner,ll);
      }
      List<Integer> list=ll[i];
      list.add(p.getPartitionId());
    }
    set.clear();
  }
  for (  Address a : map.keySet()) {
    List[] ll=map.get(a);
    for (int i=0; i < ll.length; i++) {
      int partitionCountOfNode=ll[i].size();
      if ((partitionCountOfNode < avgPartitionPerNode / 2) || (partitionCountOfNode > avgPartitionPerNode * 2)) {
        logger.log(Level.FINEST,"Replica: " + i + ", Owner: "+ a+ ", PartitonCount: "+ partitionCountOfNode+ ", AvgPartitionCount: "+ avgPartitionPerNode);
        return false;
      }
    }
  }
  return true;
}
