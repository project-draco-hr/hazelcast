{
  final int nodeSize=members.size();
  final int replicaCount=Math.min(nodeSize,PartitionInfo.MAX_REPLICA_COUNT);
  final int avgPartitionPerNode=partitionCount / nodeSize;
  final Random rand=new Random();
  if (replicaCount < PartitionInfo.MAX_REPLICA_COUNT) {
    for (    PartitionInfo partition : state) {
      for (int index=replicaCount - 1; index < PartitionInfo.MAX_REPLICA_COUNT; index++) {
        partition.setReplicaAddress(index,null);
      }
    }
  }
  Map<Address,PartitionRegistry> partitionRegistryMap=new HashMap<Address,PartitionRegistry>(nodeSize);
  for (  MemberImpl member : members) {
    partitionRegistryMap.put(member.getAddress(),new PartitionRegistry());
  }
  for (  PartitionInfo partition : state) {
    Address owner=null;
    PartitionRegistry partitionRegistry=null;
    for (int index=0; index < replicaCount; index++) {
      if ((owner=partition.getReplicaAddress(index)) != null && (partitionRegistry=partitionRegistryMap.get(owner)) != null) {
        partitionRegistry.register(partition.getPartitionId());
      }
    }
  }
  for (int index=0; index < replicaCount; index++) {
    final LinkedList<Integer> partitionsToArrange=new LinkedList<Integer>();
    int maxPartitionPerNode=avgPartitionPerNode + 1;
    int remainingPartitions=partitionCount - avgPartitionPerNode * nodeSize;
    for (    MemberImpl member : members) {
      partitionRegistryMap.get(member.getAddress()).reset();
    }
    for (    PartitionInfo partition : state) {
      Address owner=null;
      PartitionRegistry partitionRegistry=null;
      if ((owner=partition.getReplicaAddress(index)) != null && (partitionRegistry=partitionRegistryMap.get(owner)) != null) {
        partitionRegistry.add(partition.getPartitionId());
      }
 else {
        partitionsToArrange.add(partition.getPartitionId());
      }
    }
    for (    Address address : partitionRegistryMap.keySet()) {
      PartitionRegistry partitionRegistry=partitionRegistryMap.get(address);
      int size=partitionRegistry.size();
      if (size == maxPartitionPerNode) {
        if (remainingPartitions > 0 && --remainingPartitions == 0) {
          maxPartitionPerNode=avgPartitionPerNode;
        }
        continue;
      }
      int diff=(size - maxPartitionPerNode);
      for (int i=0; i < diff; i++) {
        int remove=rand.nextInt(partitionRegistry.size());
        Integer partitionId=partitionRegistry.remove(remove);
        partitionsToArrange.add(partitionId);
      }
    }
    Collections.shuffle(partitionsToArrange);
    for (    Address address : partitionRegistryMap.keySet()) {
      PartitionRegistry partitionRegistry=partitionRegistryMap.get(address);
      final int queueSize=partitionsToArrange.size();
      int count=0;
      while (partitionRegistry.size() < maxPartitionPerNode && count < queueSize) {
        Integer partitionId=partitionsToArrange.poll();
        count++;
        if (partitionRegistry.contains(partitionId)) {
          partitionsToArrange.offer(partitionId);
        }
 else {
          partitionRegistry.add(partitionId);
          PartitionInfo p=state[partitionId];
          p.setReplicaAddress(index,address);
        }
      }
      if (remainingPartitions > 0 && --remainingPartitions == 0) {
        maxPartitionPerNode=avgPartitionPerNode;
      }
    }
    while (!partitionsToArrange.isEmpty()) {
      Integer partitionId=partitionsToArrange.poll();
      MemberImpl member=members.get(rand.nextInt(members.size()));
      Address address=member.getAddress();
      PartitionRegistry partitionRegistry=partitionRegistryMap.get(address);
      if (!partitionRegistry.contains(partitionId)) {
        partitionRegistry.add(partitionId);
        PartitionInfo p=state[partitionId];
        p.setReplicaAddress(index,address);
      }
 else {
        partitionsToArrange.offer(partitionId);
      }
    }
  }
}
