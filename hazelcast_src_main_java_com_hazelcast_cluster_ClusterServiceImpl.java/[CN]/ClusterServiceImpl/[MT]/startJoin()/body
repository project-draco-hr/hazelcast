{
  logger.log(Level.FINEST,"Starting Join.");
  lock.lock();
  try {
    joinInProgress=true;
    final Collection<MemberImpl> members=getMemberList();
    final Collection<MemberInfo> memberInfos=createMemberInfos(members);
    for (    MemberImpl member : members) {
      memberInfos.add(new MemberInfo(member.getAddress(),member.getUuid()));
    }
    for (    MemberInfo memberJoining : setJoins) {
      memberInfos.add(memberJoining);
    }
    final long time=getClusterTime();
    final MemberInfoUpdateOperation memberInfoUpdateOp=new MemberInfoUpdateOperation(memberInfos,time,true);
    final Operation[] postJoinOps=nodeEngine.getPostJoinOperations();
    final PostJoinOperation postJoinOp=postJoinOps != null && postJoinOps.length > 0 ? new PostJoinOperation(postJoinOps) : null;
    final FinalizeJoinOperation finalizeJoinOp=new FinalizeJoinOperation(memberInfos,postJoinOp,time);
    final List<Future> calls=new ArrayList<Future>(members.size());
    for (    MemberInfo member : setJoins) {
      calls.add(invokeClusterOperation(finalizeJoinOp,member.getAddress()));
    }
    for (    MemberImpl member : members) {
      if (!member.getAddress().equals(thisAddress)) {
        calls.add(invokeClusterOperation(memberInfoUpdateOp,member.getAddress()));
      }
    }
    updateMembers(memberInfos);
    for (    Future future : calls) {
      try {
        future.get(3,TimeUnit.SECONDS);
      }
 catch (      TimeoutException ignored) {
        logger.log(Level.FINEST,"Finalize join call timed-out: " + future);
      }
catch (      Exception e) {
        logger.log(Level.WARNING,"While waiting finalize join calls...",e);
      }
    }
  }
  finally {
    lock.unlock();
  }
}
