{
  if (preparingToMerge.compareAndSet(true,false)) {
    node.getJoiner().setTargetAddress(newTargetAddress);
    final LifecycleServiceImpl lifecycleService=node.hazelcastInstance.getLifecycleService();
    lifecycleService.runUnderLifecycleLock(new Runnable(){
      public void run(){
        lifecycleService.fireLifecycleEvent(MERGING);
        final NodeEngineImpl nodeEngine=node.nodeEngine;
        final Collection<SplitBrainHandlerService> services=nodeEngine.getServices(SplitBrainHandlerService.class);
        final Collection<Runnable> tasks=new LinkedList<Runnable>();
        for (        SplitBrainHandlerService service : services) {
          final Runnable runnable=service.prepareMergeRunnable();
          if (runnable != null) {
            tasks.add(runnable);
          }
        }
        final Collection<ManagedService> managedServices=nodeEngine.getServices(ManagedService.class);
        for (        ManagedService service : managedServices) {
          service.reset();
        }
        node.onRestart();
        node.connectionManager.restart();
        node.rejoin();
        final Collection<Future> futures=new LinkedList<Future>();
        for (        Runnable task : tasks) {
          Future f=nodeEngine.getExecutionService().submit("hz:system",task);
          futures.add(f);
        }
        long callTimeout=node.groupProperties.OPERATION_CALL_TIMEOUT_MILLIS.getLong();
        for (        Future f : futures) {
          try {
            waitOnFutureInterruptible(f,callTimeout,TimeUnit.MILLISECONDS);
          }
 catch (          HazelcastInstanceNotActiveException e) {
            EmptyStatement.ignore(e);
          }
catch (          Exception e) {
            logger.severe("While merging...",e);
          }
        }
        if (node.isActive() && node.joined()) {
          lifecycleService.fireLifecycleEvent(MERGED);
        }
      }
    }
);
  }
}
