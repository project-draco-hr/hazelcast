{
  if (responseAvailable(response)) {
    return response;
  }
  WAITER_COUNT.incrementAndGet(this);
  try {
    long timeoutMs=toTimeoutMs(time,unit);
    long maxCallTimeoutMs=getMaxCallTimeout();
    boolean longPolling=timeoutMs > maxCallTimeoutMs;
    int pollCount=0;
    while (timeoutMs >= 0) {
      long pollTimeoutMs=min(maxCallTimeoutMs,timeoutMs);
      long startMs=Clock.currentTimeMillis();
      long lastPollTime=0;
      pollCount++;
      try {
        pollResponse(pollTimeoutMs);
        lastPollTime=Clock.currentTimeMillis() - startMs;
        timeoutMs=decrementTimeout(timeoutMs,lastPollTime);
        if (response == WAIT_RESPONSE) {
          RESPONSE.compareAndSet(this,WAIT_RESPONSE,null);
          continue;
        }
 else         if (response != null) {
          if (response != INTERRUPTED_RESPONSE && interrupted) {
            Thread.currentThread().interrupt();
          }
          return response;
        }
      }
 catch (      InterruptedException e) {
        interrupted=true;
      }
      if (!interrupted && longPolling) {
        Address target=invocation.getTarget();
        if (invocation.remote && invocation.nodeEngine.getThisAddress().equals(target)) {
          continue;
        }
        invocation.logger.warning("No response for " + lastPollTime + " ms. "+ toString());
        boolean executing=operationService.getIsStillRunningService().isOperationExecuting(invocation);
        if (!executing) {
          Object operationTimeoutException=invocation.newOperationTimeoutException(pollCount * pollTimeoutMs);
          if (response != null) {
            continue;
          }
          complete(operationTimeoutException);
        }
      }
    }
    return TIMEOUT_RESPONSE;
  }
  finally {
    WAITER_COUNT.decrementAndGet(this);
  }
}
