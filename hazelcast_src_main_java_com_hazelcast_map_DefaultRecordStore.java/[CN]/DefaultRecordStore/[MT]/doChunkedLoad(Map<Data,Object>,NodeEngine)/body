{
  final int mapLoadChunkSize=nodeEngine.getGroupProperties().MAP_LOAD_CHUNK_SIZE.getInteger();
  final Queue<Map> chunks=new LinkedList<Map>();
  Map<Data,Object> partitionKeys=new HashMap<Data,Object>();
  Iterator<Map.Entry<Data,Object>> iterator=loadedKeys.entrySet().iterator();
  while (iterator.hasNext()) {
    final Map.Entry<Data,Object> entry=iterator.next();
    final Data data=entry.getKey();
    if (partitionId == nodeEngine.getPartitionService().getPartitionId(data)) {
      partitionKeys.put(data,entry.getValue());
      if (partitionKeys.size() >= mapLoadChunkSize) {
        chunks.add(partitionKeys);
        partitionKeys=new HashMap<Data,Object>();
      }
      iterator.remove();
    }
  }
  if (!partitionKeys.isEmpty()) {
    chunks.add(partitionKeys);
  }
  if (chunks.isEmpty()) {
    loaded.set(true);
    return;
  }
  try {
    final AtomicInteger checkIfMapLoaded=new AtomicInteger(chunks.size());
    Map<Data,Object> chunkedKeys;
    while ((chunkedKeys=chunks.poll()) != null) {
      nodeEngine.getExecutionService().submit("hz:map-load",new MapLoadAllTask(chunkedKeys,checkIfMapLoaded));
    }
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}
