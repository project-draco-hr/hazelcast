{
  this.nodeEngine=nodeEngine;
  this.node=nodeEngine.getNode();
  this.logger=node.getLogger(OperationService.class.getName());
  defaultCallTimeout=node.getGroupProperties().OPERATION_CALL_TIMEOUT_MILLIS.getLong();
  final int coreSize=Runtime.getRuntime().availableProcessors();
  final String poolNamePrefix=node.getThreadPoolNamePrefix("operation");
  executor=new FastExecutor(coreSize,poolNamePrefix,new PoolExecutorThreadFactory(node.threadGroup,poolNamePrefix,node.getConfig().getClassLoader()));
  executor.setInterceptor(new FastExecutor.WorkerLifecycleInterceptor(){
    public void beforeWorkerStart(){
      logger.log(Level.INFO,"Creating a new operation thread -> Core: " + executor.getCoreThreadSize() + ", Current: "+ (executor.getActiveThreadCount() + 1)+ ", Max: "+ executor.getMaxThreadSize());
    }
    public void afterWorkerTerminate(){
      logger.log(Level.INFO,"Destroying an operation thread -> Core: " + executor.getCoreThreadSize() + ", Current: "+ executor.getActiveThreadCount()+ ", Max: "+ executor.getMaxThreadSize());
    }
  }
);
  ownerLocks=new Lock[100000];
  for (int i=0; i < ownerLocks.length; i++) {
    ownerLocks[i]=new ReentrantLock();
  }
  backupLocks=new Lock[10000];
  for (int i=0; i < backupLocks.length; i++) {
    backupLocks[i]=new ReentrantLock();
  }
  int partitionCount=node.groupProperties.PARTITION_COUNT.getInteger();
  partitionLocks=new SpinReadWriteLock[partitionCount];
  for (int i=0; i < partitionCount; i++) {
    partitionLocks[i]=new SpinReadWriteLock(1,TimeUnit.MILLISECONDS);
  }
}
