{
  int mapLoadChunkSize=getLoadBatchSize();
  Queue<Map> chunks=new LinkedList<Map>();
  Map<Data,Object> partitionKeys=new HashMap<Data,Object>();
  InternalPartitionService partitionService=nodeEngine.getPartitionService();
  Iterator<Map.Entry<Data,Object>> iterator=loadedKeys.entrySet().iterator();
  while (iterator.hasNext()) {
    final Map.Entry<Data,Object> entry=iterator.next();
    final Data key=entry.getKey();
    if (partitionId == partitionService.getPartitionId(key) && shouldLoad(key,replaceExisting)) {
      partitionKeys.put(key,entry.getValue());
      if (partitionKeys.size() >= mapLoadChunkSize) {
        chunks.add(partitionKeys);
        partitionKeys=new HashMap<Data,Object>();
      }
      iterator.remove();
    }
  }
  if (!partitionKeys.isEmpty()) {
    chunks.add(partitionKeys);
  }
  if (chunks.isEmpty()) {
    setLoaded(true);
    return;
  }
  try {
    this.throwable=null;
    final AtomicInteger checkIfMapLoaded=new AtomicInteger(chunks.size());
    ExecutionService executionService=nodeEngine.getExecutionService();
    Map<Data,Object> chunkedKeys;
    while ((chunkedKeys=chunks.poll()) != null) {
      final Callback<Throwable> callback=createCallbackForThrowable();
      MapLoadAllTask task=new MapLoadAllTask(chunkedKeys,checkIfMapLoaded,callback);
      executionService.submit(ExecutionService.MAP_LOADER_EXECUTOR,task);
    }
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}
