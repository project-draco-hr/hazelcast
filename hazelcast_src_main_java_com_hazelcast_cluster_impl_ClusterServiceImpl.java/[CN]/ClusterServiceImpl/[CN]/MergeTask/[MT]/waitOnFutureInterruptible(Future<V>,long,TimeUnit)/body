{
  isNotNull(timeUnit,"timeUnit");
  long deadline=Clock.currentTimeMillis() + timeUnit.toMillis(timeout);
  while (true) {
    long localTimeoutMs=Math.min(MIN_WAIT_ON_FUTURE_TIMEOUT_MILLIS,deadline);
    try {
      return future.get(localTimeoutMs,TimeUnit.MILLISECONDS);
    }
 catch (    TimeoutException t) {
      deadline-=localTimeoutMs;
      if (deadline <= 0) {
        throw t;
      }
      if (node.getState() != NodeState.ACTIVE) {
        future.cancel(true);
        throw new HazelcastInstanceNotActiveException();
      }
    }
  }
}
