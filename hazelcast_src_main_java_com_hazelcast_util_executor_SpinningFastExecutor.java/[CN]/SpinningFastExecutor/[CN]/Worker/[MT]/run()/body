{
  final Thread currentThread=Thread.currentThread();
  final long timeout=keepAliveMillis;
  final int park=100000;
  final int spin=park + 1000;
  WorkerTask task=null;
  while (!currentThread.isInterrupted() && isLive()) {
    spinningThreads.incrementAndGet();
    int c=spin;
    while (c > 0) {
      task=queue.poll();
      if (task != null) {
        task.run();
        c=spin;
      }
 else {
        if (currentThread.isInterrupted()) {
          return;
        }
        if (c-- < park) {
          LockSupport.parkNanos(1L);
        }
      }
    }
    try {
      lock.lockInterruptibly();
      try {
        spinningThreads.decrementAndGet();
        signalWorker.await(timeout,TimeUnit.MILLISECONDS);
        task=queue.poll();
        System.err.println("DEBUG: Awaken from sleep -> " + currentThread.getName() + " TASK: "+ task);
        if (task == null && removeWorker(currentThread)) {
          return;
        }
      }
  finally {
        lock.unlock();
      }
    }
 catch (    InterruptedException e) {
      break;
    }
    if (task != null) {
      task.run();
    }
  }
}
