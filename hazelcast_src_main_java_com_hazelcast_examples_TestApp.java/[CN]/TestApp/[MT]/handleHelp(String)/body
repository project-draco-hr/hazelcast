{
  boolean silentBefore=silent;
  silent=false;
  println("Commands:");
  println("-- General commands");
  println("echo true|false                      //turns on/off echo of commands (default false)");
  println("silent true|false                    //turns on/off silent of command output (default false)");
  println("#<number> <command>                  //repeats <number> time <command>, replace $i in <command> with current iteration (0..<number-1>)");
  println("&<number> <command>                  //forks <number> threads to execute <command>, replace $t in <command> with current thread number (0..<number-1>");
  println("     When using #x or &x, is is advised to use silent true as well.");
  println("     When using &x with m.putmany and m.removemany, each thread will get a different share of keys unless a start key index is specified");
  println("jvm                                  //displays info about the runtime");
  println("who                                  //displays info about the cluster");
  println("whoami                               //displays info about this cluster member");
  println("ns <string>                          //switch the namespace for using the distributed queue/map/set/list <string> (defaults to \"default\"");
  println("@<file>                              //executes the given <file> script. Use '//' for comments in the script");
  println("");
  println("-- Queue commands");
  println("q.offer <string>                     //adds a string object to the queue");
  println("q.poll                               //takes an object from the queue");
  println("q.offermany <number> [<size>]        //adds indicated number of string objects to the queue ('obj<i>' or byte[<size>]) ");
  println("q.pollmany <number>                  //takes indicated number of objects from the queue");
  println("q.iterator [remove]                  //iterates the queue, remove if specified");
  println("q.size                               //size of the queue");
  println("q.clear                              //clears the queue");
  println("");
  println("-- Set commands");
  println("s.add <string>                       //adds a string object to the set");
  println("s.remove <string>                    //removes the string object from the set");
  println("s.addmany <number>                   //adds indicated number of string objects to the set ('obj<i>')");
  println("s.removemany <number>                //takes indicated number of objects from the set");
  println("s.iterator [remove]                  //iterates the set, removes if specified");
  println("s.size                               //size of the set");
  println("s.clear                              //clears the set");
  println("");
  println("-- Lock commands");
  println("lock <key>                           //same as Hazelcast.getLock(key).lock()");
  println("tryLock <key>                        //same as Hazelcast.getLock(key).tryLock()");
  println("tryLock <key> <time>                 //same as tryLock <key> with timeout in seconds");
  println("unlock <key>                         //same as Hazelcast.getLock(key).unlock()");
  println("");
  println("-- Map commands");
  println("m.put <key> <value>                  //puts an entry to the map");
  println("m.remove <key>                       //removes the entry of given key from the map");
  println("m.get <key>                          //returns the value of given key from the map");
  println("m.putmany <number> [<size>] [<index>]//puts indicated number of entries to the map ('key<i>':byte[<size>], <index>+(0..<number>)");
  println("m.removemany <number> [<index>]      //removes indicated number of entries from the map ('key<i>', <index>+(0..<number>)");
  println("     When using &x with m.putmany and m.removemany, each thread will get a different share of keys unless a start key <index> is specified");
  println("m.keys                               //iterates the keys of the map");
  println("m.values                             //iterates the values of the map");
  println("m.entries                            //iterates the entries of the map");
  println("m.iterator [remove]                  //iterates the keys of the map, remove if specified");
  println("m.size                               //size of the map");
  println("m.clear                              //clears the map");
  println("m.destroy                            //destroys the map");
  println("m.lock <key>                         //locks the key");
  println("m.tryLock <key>                      //tries to lock the key and returns immediately");
  println("m.tryLock <key> <time>               //tries to lock the key within given seconds");
  println("m.unlock <key>                       //unlocks the key");
  println("");
  println("-- List commands:");
  println("l.add <string>");
  println("l.add <index> <string>");
  println("l.contains <string>");
  println("l.remove <string>");
  println("l.remove <index>");
  println("l.set <index> <string>");
  println("l.iterator [remove]");
  println("l.size");
  println("l.clear");
  println("execute	<echo-input>				//executes an echo task on random member");
  println("execute0nKey	<echo-input> <key>		//executes an echo task on the member that owns the given key");
  println("execute0nMember <echo-input> <key>	//executes an echo task on the member with given index");
  println("execute0nMembers <echo-input> 		//executes an echo task on all of the members");
  println("");
  silent=silentBefore;
}
