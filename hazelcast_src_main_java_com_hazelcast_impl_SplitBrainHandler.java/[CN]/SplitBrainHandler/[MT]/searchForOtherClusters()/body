{
  if (multicastEnabled && node.multicastService != null) {
    final BlockingQueue q=new LinkedBlockingQueue();
    MulticastListener listener=new MulticastListener(){
      public void onMessage(      Object msg){
        if (msg != null && msg instanceof JoinInfo) {
          JoinInfo joinInfo=(JoinInfo)msg;
          if (node.address != null && !node.address.equals(joinInfo.address)) {
            q.offer(msg);
          }
        }
      }
    }
;
    node.multicastService.addMulticastListener(listener);
    node.multicastService.send(node.createJoinInfo());
    try {
      JoinInfo joinInfo=(JoinInfo)q.poll(3,TimeUnit.SECONDS);
      if (joinInfo != null) {
        node.multicastService.removeMulticastListener(listener);
        if (shouldMerge(joinInfo)) {
          logger.log(Level.WARNING,node.address + " is merging [multicast] to " + joinInfo.address);
          node.factory.restart();
          return;
        }
      }
    }
 catch (    InterruptedException ignored) {
    }
catch (    Exception e) {
      e.printStackTrace();
    }
  }
  if (tcpEnabled) {
    final Collection<Address> colPossibleAddresses;
    try {
      colPossibleAddresses=Node.getPossibleMembers(node.getConfig(),node.getThisAddress(),logger);
    }
 catch (    Throwable e) {
      logger.log(Level.SEVERE,e.getMessage(),e);
      return;
    }
    colPossibleAddresses.remove(node.getThisAddress());
    for (    Member member : node.getClusterImpl().getMembers()) {
      colPossibleAddresses.remove(((MemberImpl)member).getAddress());
    }
    if (colPossibleAddresses.size() == 0) {
      return;
    }
    for (    final Address possibleAddress : colPossibleAddresses) {
      logger.log(Level.FINEST,node.getThisAddress() + " is connecting to " + possibleAddress);
      node.connectionManager.getOrConnect(possibleAddress);
    }
    for (    Address possibleAddress : colPossibleAddresses) {
      try {
        Thread.sleep(1000);
      }
 catch (      InterruptedException e) {
        return;
      }
      final Connection conn=node.connectionManager.getOrConnect(possibleAddress);
      if (conn != null) {
        JoinInfo response=node.clusterManager.checkJoin(conn);
        if (shouldMerge(response)) {
          logger.log(Level.WARNING,node.address + " is merging [tcp/ip] to " + possibleAddress);
          lastRun=System.currentTimeMillis() + FIRST_RUN_DELAY_MILLIS;
          node.factory.restart();
        }
        return;
      }
    }
  }
}
