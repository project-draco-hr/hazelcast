{
  sb.append("\"").append(info.getThreadName()).append("\"").append(" Id=").append(info.getThreadId()).append(" ").append(info.getThreadState());
  if (info.getLockName() != null) {
    sb.append(" on ").append(info.getLockName());
  }
  if (info.getLockOwnerName() != null) {
    sb.append(" owned by \"").append(info.getLockOwnerName()).append("\" Id=").append(+info.getLockOwnerId());
  }
  if (info.isSuspended()) {
    sb.append(" (suspended)");
  }
  if (info.isInNative()) {
    sb.append(" (in native)");
  }
  sb.append('\n');
  final StackTraceElement[] stackTrace=info.getStackTrace();
  final Object lockInfo=objectCall(info,ThreadInfo_getLockInfo);
  final Object[] monitorInfo=(Object[])objectCall(info,ThreadInfo_getLockedMonitors);
  for (int i=0; i < stackTrace.length; i++) {
    StackTraceElement ste=stackTrace[i];
    sb.append("\tat ").append(ste.toString());
    sb.append('\n');
    if (i == 0 && lockInfo != null) {
      Thread.State ts=info.getThreadState();
switch (ts) {
case BLOCKED:
        sb.append("\t-  blocked on ").append(lockInfo);
      sb.append('\n');
    break;
case WAITING:
  sb.append("\t-  waiting on ").append(lockInfo);
sb.append('\n');
break;
case TIMED_WAITING:
sb.append("\t-  waiting on ").append(lockInfo);
sb.append('\n');
break;
default :
}
}
for (Object mi : monitorInfo) {
Integer depth=objectCall(mi,MonitorInfo_getLockedStackDepth);
if (depth == i) {
sb.append("\t-  locked ").append(mi);
sb.append('\n');
}
}
}
final Object[] locks=(Object[])objectCall(info,ThreadInfo_getLockedSynchronizers);
if (locks.length > 0) {
sb.append("\n\tNumber of locked synchronizers = ").append(locks.length);
sb.append('\n');
for (Object li : locks) {
sb.append("\t- ").append(li);
sb.append('\n');
}
}
sb.append('\n');
}
