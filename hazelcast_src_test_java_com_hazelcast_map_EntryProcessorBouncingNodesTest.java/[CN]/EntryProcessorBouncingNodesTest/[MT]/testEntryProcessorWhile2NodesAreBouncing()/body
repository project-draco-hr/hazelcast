{
  CountDownLatch startLatch=new CountDownLatch(1);
  AtomicBoolean isRunning=new AtomicBoolean(true);
  HazelcastInstance instance=newInstance();
  HazelcastInstance instance2=newInstance();
  HazelcastInstance instance3=newInstance();
  final IMap<Integer,List<Integer>> map=instance.getMap(MAP_NAME);
  final List<Integer> expected=new ArrayList<Integer>();
  InitListProcessor initProcessor=new InitListProcessor();
  for (int i=0; i < ENTRIES; ++i) {
    map.executeOnKey(i,initProcessor);
  }
  assertEquals(ENTRIES,map.size());
  Thread bounceThread1=new Thread(new TwoNodesRestartingRunnable(instance2,instance3,startLatch,isRunning));
  bounceThread1.start();
  int iteration=0;
  while (iteration < ITERATIONS) {
    if (iteration == 30) {
      startLatch.countDown();
    }
    IncrementProcessor processor=new IncrementProcessor(iteration);
    expected.add(iteration);
    for (int i=0; i < ENTRIES; ++i) {
      map.executeOnKey(i,processor);
    }
    ++iteration;
  }
  isRunning.set(false);
  bounceThread1.join();
  final CountDownLatch latch=new CountDownLatch(ENTRIES);
  for (int i=0; i < ENTRIES; ++i) {
    final int id=i;
    new Thread(new Runnable(){
      @Override public void run(){
        assertTrueEventually(new AssertTask(){
          @Override public void run() throws Exception {
            assertTrue(expected.size() <= map.get(id).size());
          }
        }
);
        latch.countDown();
      }
    }
).start();
  }
  assertOpenEventually(latch);
}
