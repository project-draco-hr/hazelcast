{
  CountDownLatch startLatch=new CountDownLatch(1);
  AtomicBoolean isRunning=new AtomicBoolean(true);
  HazelcastInstance instance=newInstance();
  HazelcastInstance instance2=newInstance();
  HazelcastInstance instance3=newInstance();
  IMap<Integer,List<Integer>> map=instance.getMap(MAP_NAME);
  List<Integer> expected=new ArrayList<Integer>();
  InitListProcessor initProcessor=new InitListProcessor();
  for (int i=0; i < ENTRIES; ++i) {
    map.executeOnKey(i,initProcessor);
  }
  assertEquals(ENTRIES,map.size());
  Thread bounceThread1=new Thread(new RestartNodeRunnable(instance2,startLatch,isRunning));
  Thread bounceThread2=new Thread(new RestartNodeRunnable(instance3,startLatch,isRunning));
  bounceThread1.start();
  bounceThread2.start();
  int iteration=0;
  while (iteration < ITERATIONS) {
    if (iteration == 30) {
      startLatch.countDown();
    }
    IncrementProcessor processor=new IncrementProcessor(iteration);
    expected.add(iteration);
    for (int i=0; i < ENTRIES; ++i) {
      map.executeOnKey(i,processor);
    }
    ++iteration;
  }
  isRunning.set(false);
  bounceThread1.join();
  bounceThread2.join();
  PartitionService partitionService=instance.getPartitionService();
  List<String> errors=new ArrayList<String>();
  for (int i=0; i < ENTRIES; ++i) {
    List<Integer> list=map.get(i);
    if (expected.size() <= list.size()) {
      continue;
    }
    String owner=partitionService.getPartition(i).getOwner().getUuid();
    String error=owner + "[" + i+ "] doesn't match! Expected/actual length: "+ expected.size()+ "/"+ list.size()+ "\nExpected : "+ expected.toString()+ "\nActual   : "+ list+ "\n";
    errors.add(error);
  }
  assertEquals(Collections.emptyList(),errors);
}
