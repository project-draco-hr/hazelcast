{
  final AtomicBoolean stop=new AtomicBoolean(false);
  final ICache cache=createCache();
  final int size=2222;
  for (int i=0; i < size; i++) {
    cache.put(i,i);
  }
  final Thread thread=new Thread(){
    public void run(){
      Random rand=new Random();
      while (!stop.get()) {
        int i=rand.nextInt(size);
        try {
          cache.remove(i);
          LockSupport.parkNanos(1);
        }
 catch (        Throwable ignored) {
        }
      }
    }
  }
;
  thread.start();
  sleepSeconds(1);
  try {
    int k=0;
    Iterator<Cache.Entry<Integer,Integer>> iter=cache.iterator();
    while (iter.hasNext()) {
      Cache.Entry<Integer,Integer> e=iter.next();
      int key=e.getKey();
      Integer value=e.getValue();
      if (value != null) {
        assertEquals(key,value.intValue());
      }
      k++;
    }
    assertTrue(k <= size);
  }
  finally {
    stop.set(true);
    thread.join();
  }
}
