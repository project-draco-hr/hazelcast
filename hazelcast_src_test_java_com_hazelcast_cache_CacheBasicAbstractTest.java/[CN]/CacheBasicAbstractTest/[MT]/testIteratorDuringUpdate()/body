{
  final AtomicBoolean stop=new AtomicBoolean(false);
  final ICache cache=createCache();
  final int size=1111;
  for (int i=0; i < size; i++) {
    cache.put(i,i);
  }
  final Thread thread=new Thread(){
    public void run(){
      Random rand=new Random();
      while (!stop.get()) {
        int i=rand.nextInt(size);
        try {
          cache.put(i,-i);
          LockSupport.parkNanos(1);
        }
 catch (        Throwable ignored) {
        }
      }
    }
  }
;
  thread.start();
  sleepSeconds(1);
  try {
    int k=0;
    Iterator<Cache.Entry<Integer,Integer>> iter=cache.iterator();
    while (iter.hasNext()) {
      Cache.Entry<Integer,Integer> e=iter.next();
      int key=e.getKey();
      int value=e.getValue();
      assertTrue("Key: " + key + ", Value: "+ value,key == Math.abs(value));
      k++;
    }
    assertEquals(size,k);
  }
  finally {
    stop.set(true);
    thread.join();
  }
}
