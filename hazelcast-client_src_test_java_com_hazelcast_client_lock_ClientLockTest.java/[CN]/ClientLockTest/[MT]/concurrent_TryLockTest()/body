{
  upTotal=0;
  downTotal=0;
  final Random random=new Random();
  ArrayList<CountDownLatch> latches=new ArrayList<CountDownLatch>();
  final ILock lock=hz.getLock("concurrent_TryLockTest");
  for (int threads=0; threads < 8; threads++) {
    final CountDownLatch latch=new CountDownLatch(1);
    latches.add(latch);
    new Thread(){
      public void run(){
        for (int i=0; i < 1000 * 10; i++) {
          try {
            if (lock.tryLock(10,TimeUnit.MILLISECONDS)) {
              int dif=random.nextInt(1000);
              upTotal+=dif;
              downTotal-=dif;
              lock.unlock();
            }
          }
 catch (          InterruptedException e) {
            e.printStackTrace();
          }
        }
        latch.countDown();
      }
    }
.start();
  }
  for (  CountDownLatch latch : latches) {
    assertTrue("a thread failed to complete in as least 1 minutes",latch.await(1,TimeUnit.MINUTES));
  }
  assertTrue("concurrent access to locked code caused wrong total",upTotal + downTotal == 0);
}
