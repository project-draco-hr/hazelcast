{
  MapContainer mapContainer=getMapContainer(mapName);
  LocalMapStatsImpl localMapStats=getLocalMapStatsImpl(mapName);
  if (!mapContainer.getMapConfig().isStatisticsEnabled()) {
    return localMapStats;
  }
  long ownedEntryCount=0;
  long backupEntryCount=0;
  long dirtyCount=0;
  long ownedEntryMemoryCost=0;
  long backupEntryMemoryCost=0;
  long hits=0;
  long lockedEntryCount=0;
  long heapCost=0;
  int backupCount=mapContainer.getTotalBackupCount();
  ClusterService clusterService=nodeEngine.getClusterService();
  final InternalPartitionService partitionService=nodeEngine.getPartitionService();
  final TimeUnit unit=TimeUnit.NANOSECONDS;
  Address thisAddress=clusterService.getThisAddress();
  for (int partitionId=0; partitionId < partitionService.getPartitionCount(); partitionId++) {
    InternalPartition partition=partitionService.getPartition(partitionId);
    Address owner=partition.getOwner();
    if (owner == null) {
      continue;
    }
    if (owner.equals(thisAddress)) {
      PartitionContainer partitionContainer=getPartitionContainer(partitionId);
      RecordStore recordStore=partitionContainer.getExistingRecordStore(mapName);
      if (recordStore != null) {
        heapCost+=recordStore.getHeapCost();
        Map<Data,Record> records=recordStore.getReadonlyRecordMap();
        for (        Record record : records.values()) {
          RecordStatistics stats=record.getStatistics();
          ownedEntryCount++;
          ownedEntryMemoryCost+=record.getCost();
          localMapStats.setLastAccessTime(unit.toMillis(record.getLastAccessTime()));
          localMapStats.setLastUpdateTime(unit.toMillis(record.getLastUpdateTime()));
          hits+=stats.getHits();
          if (recordStore.isLocked(record.getKey())) {
            lockedEntryCount++;
          }
        }
        dirtyCount+=recordStore.getWriteBehindQueue().size();
      }
    }
 else {
      for (int replica=1; replica <= backupCount; replica++) {
        Address replicaAddress=partition.getReplicaAddress(replica);
        int tryCount=30;
        while (replicaAddress == null && clusterService.getSize() > backupCount && tryCount-- > 0) {
          try {
            TimeUnit.MILLISECONDS.sleep(100);
          }
 catch (          InterruptedException e) {
            throw ExceptionUtil.rethrow(e);
          }
          replicaAddress=partition.getReplicaAddress(replica);
        }
        if (replicaAddress != null && replicaAddress.equals(thisAddress)) {
          PartitionContainer partitionContainer=getPartitionContainer(partitionId);
          RecordStore recordStore=partitionContainer.getRecordStore(mapName);
          heapCost+=recordStore.getHeapCost();
          Map<Data,Record> records=recordStore.getReadonlyRecordMap();
          for (          Record record : records.values()) {
            backupEntryCount++;
            backupEntryMemoryCost+=record.getCost();
          }
        }
 else         if (replicaAddress == null && clusterService.getSize() > backupCount) {
          logger.warning("Partition: " + partition + ", replica: "+ replica+ " has no owner!");
        }
      }
    }
  }
  localMapStats.setBackupCount(backupCount);
  localMapStats.setDirtyEntryCount(zeroOrPositive(dirtyCount));
  localMapStats.setLockedEntryCount(zeroOrPositive(lockedEntryCount));
  localMapStats.setHits(zeroOrPositive(hits));
  localMapStats.setOwnedEntryCount(zeroOrPositive(ownedEntryCount));
  localMapStats.setBackupEntryCount(zeroOrPositive(backupEntryCount));
  localMapStats.setOwnedEntryMemoryCost(zeroOrPositive(ownedEntryMemoryCost));
  localMapStats.setBackupEntryMemoryCost(zeroOrPositive(backupEntryMemoryCost));
  heapCost+=mapContainer.getNearCacheSizeEstimator().getSize();
  localMapStats.setHeapCost(heapCost);
  if (mapContainer.getMapConfig().isNearCacheEnabled()) {
    NearCacheStatsImpl nearCacheStats=getNearCache(mapName).getNearCacheStats();
    localMapStats.setNearCacheStats(nearCacheStats);
  }
  return localMapStats;
}
