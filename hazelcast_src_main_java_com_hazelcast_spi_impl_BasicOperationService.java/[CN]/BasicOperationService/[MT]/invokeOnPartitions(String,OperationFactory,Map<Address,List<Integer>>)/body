{
  final Thread currentThread=Thread.currentThread();
  if (currentThread instanceof BasicOperationServiceExecutor.PartitionThread) {
    throw new IllegalThreadStateException(currentThread + " cannot make invocation on multiple partitions!");
  }
  final Map<Address,Future> responses=new HashMap<Address,Future>(memberPartitions.size());
  for (  Map.Entry<Address,List<Integer>> mp : memberPartitions.entrySet()) {
    final Address address=mp.getKey();
    final List<Integer> partitions=mp.getValue();
    final PartitionIteratingOperation pi=new PartitionIteratingOperation(partitions,operationFactory);
    Future future=createInvocationBuilder(serviceName,pi,address).setTryCount(10).setTryPauseMillis(300).invoke();
    responses.put(address,future);
  }
  final Map<Integer,Object> partitionResults=new HashMap<Integer,Object>(nodeEngine.getPartitionService().getPartitionCount());
  for (  Map.Entry<Address,Future> response : responses.entrySet()) {
    try {
      PartitionResponse result=(PartitionResponse)nodeEngine.toObject(response.getValue().get());
      partitionResults.putAll(result.asMap());
    }
 catch (    Throwable t) {
      if (logger.isFinestEnabled()) {
        logger.finest(t);
      }
 else {
        logger.warning(t.getMessage());
      }
      List<Integer> partitions=memberPartitions.get(response.getKey());
      for (      Integer partition : partitions) {
        partitionResults.put(partition,t);
      }
    }
  }
  final List<Integer> failedPartitions=new LinkedList<Integer>();
  for (  Map.Entry<Integer,Object> partitionResult : partitionResults.entrySet()) {
    int partitionId=partitionResult.getKey();
    Object result=partitionResult.getValue();
    if (result instanceof Throwable) {
      failedPartitions.add(partitionId);
    }
  }
  for (  Integer failedPartition : failedPartitions) {
    Future f=createInvocationBuilder(serviceName,operationFactory.createOperation(),failedPartition).invoke();
    partitionResults.put(failedPartition,f);
  }
  for (  Integer failedPartition : failedPartitions) {
    Future f=(Future)partitionResults.get(failedPartition);
    Object result=f.get();
    partitionResults.put(failedPartition,result);
  }
  return partitionResults;
}
