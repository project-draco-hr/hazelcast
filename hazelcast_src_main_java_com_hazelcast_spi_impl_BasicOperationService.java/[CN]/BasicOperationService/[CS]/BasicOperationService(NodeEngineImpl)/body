{
  this.nodeEngine=nodeEngine;
  this.node=nodeEngine.getNode();
  this.logger=node.getLogger(OperationService.class);
  this.invocationLogger=nodeEngine.getLogger(BasicInvocation.class);
  this.defaultCallTimeoutMillis=node.getGroupProperties().OPERATION_CALL_TIMEOUT_MILLIS.getLong();
  this.backupOperationTimeoutMillis=node.getGroupProperties().OPERATION_BACKUP_TIMEOUT_MILLIS.getLong();
  this.executionService=nodeEngine.getExecutionService();
  this.backPressureService=new BasicBackPressureService(node.getGroupProperties(),logger);
  int coreSize=Runtime.getRuntime().availableProcessors();
  boolean reallyMultiCore=coreSize >= CORE_SIZE_CHECK;
  int concurrencyLevel=reallyMultiCore ? coreSize * CORE_SIZE_FACTOR : CONCURRENCY_LEVEL;
  this.executingCalls=new ConcurrentHashMap<RemoteCallKey,RemoteCallKey>(INITIAL_CAPACITY,LOAD_FACTOR,concurrencyLevel);
  this.invocations=new ConcurrentHashMap<Long,BasicInvocation>(INITIAL_CAPACITY,LOAD_FACTOR,concurrencyLevel);
  this.scheduler=new BasicOperationScheduler(node,executionService,new BasicDispatcherImpl());
  this.operationHandler=new OperationHandler();
  this.operationBackupHandler=new OperationBackupHandler();
  this.operationPacketHandler=new OperationPacketHandler();
  this.responsePacketHandler=new ResponsePacketHandler();
  this.asyncExecutor=executionService.register(ExecutionService.ASYNC_EXECUTOR,coreSize,ASYNC_QUEUE_CAPACITY,ExecutorType.CONCRETE);
  this.cleanupThread=new CleanupThread();
  this.cleanupThread.start();
}
