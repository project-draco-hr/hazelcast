{
  this.nodeEngine=nodeEngine;
  this.node=nodeEngine.getNode();
  this.logger=node.getLogger(OperationService.class.getName());
  defaultCallTimeout=node.getGroupProperties().OPERATION_CALL_TIMEOUT_MILLIS.getLong();
  final int coreSize=Runtime.getRuntime().availableProcessors();
  final boolean reallyMultiCore=coreSize >= 8;
  final int concurrencyLevel=reallyMultiCore ? coreSize * 4 : 16;
  remoteCalls=new ConcurrentHashMap<Long,RemoteCall>(1000,0.75f,concurrencyLevel);
  final int opThreadCount=node.getGroupProperties().OPERATION_THREAD_COUNT.getInteger();
  operationThreadCount=opThreadCount > 0 ? opThreadCount : coreSize * 2;
  operationExecutors=new ExecutorService[operationThreadCount];
  operationExecutorQueues=new BlockingQueue[operationThreadCount];
  for (int i=0; i < operationExecutors.length; i++) {
    BlockingQueue<Runnable> q=new LinkedBlockingQueue<Runnable>();
    operationExecutorQueues[i]=q;
    operationExecutors[i]=new ThreadPoolExecutor(1,1,0L,TimeUnit.MILLISECONDS,q,new OperationThreadFactory(i));
  }
  final ExecutionService executionService=nodeEngine.getExecutionService();
  defaultOperationExecutor=executionService.register(ExecutionService.OPERATION_EXECUTOR,coreSize * 2,coreSize * 100000);
  executionService.register(ExecutionService.ASYNC_EXECUTOR,coreSize * 10,coreSize * 100000);
  responseExecutor=new ThreadPoolExecutor(1,1,0L,TimeUnit.MILLISECONDS,responseWorkQueue,new SingleExecutorThreadFactory(node.threadGroup,node.getConfigClassLoader(),node.getThreadNamePrefix("response")));
  executingCalls=new ConcurrentHashMap<RemoteCallKey,RemoteCallKey>(1000,0.75f,concurrencyLevel);
  backupCalls=new ConcurrentHashMap<Long,BackupCompletionCallback>(1000,0.75f,concurrencyLevel);
  backupScheduler=EntryTaskSchedulerFactory.newScheduler(executionService.getScheduledExecutor(),new ScheduledBackupProcessor(),ScheduleType.SCHEDULE_IF_NEW);
}
