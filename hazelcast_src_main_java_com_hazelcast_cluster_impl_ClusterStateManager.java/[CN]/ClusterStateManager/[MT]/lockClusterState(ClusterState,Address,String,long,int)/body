{
  Preconditions.checkNotNull(newState);
  clusterServiceLock.lock();
  try {
    if (newState != ClusterState.ACTIVE) {
      final InternalPartitionService partitionService=node.getPartitionService();
      final int thisPartitionStateVersion=partitionService.getPartitionStateVersion();
      if (partitionService.hasOnGoingMigrationLocal()) {
        throw new IllegalStateException("Still have pending migration/replication tasks, " + "cannot lock cluster state! New state: " + newState + ", current state: "+ getState());
      }
 else       if (partitionStateVersion != thisPartitionStateVersion) {
        throw new IllegalStateException("Can not lock cluster state! Partition tables have different versions! " + "Expected version: " + partitionStateVersion + " Current version: "+ thisPartitionStateVersion);
      }
    }
    final ClusterStateLock currentLock=getStateLock();
    if (!currentLock.allowsLock(txnId)) {
      throw new TransactionException("Locking failed for " + initiator + ", tx: "+ txnId+ ", current state: "+ toString());
    }
    stateLockRef.set(new ClusterStateLock(initiator,txnId,leaseTime));
  }
  finally {
    clusterServiceLock.unlock();
  }
}
