{
  boolean strong=false;
  Set<MapEntry> results=null;
  try {
    if (predicate != null && predicate instanceof IndexAwarePredicate) {
      List<IndexAwarePredicate> lsIndexAwarePredicates=new ArrayList<IndexAwarePredicate>();
      IndexAwarePredicate iap=(IndexAwarePredicate)predicate;
      strong=iap.collectIndexAwarePredicates(lsIndexAwarePredicates,mapIndexes);
      if (strong) {
        Set<Index> setAppliedIndexes=new HashSet<Index>(1);
        iap.collectAppliedIndexes(setAppliedIndexes,mapIndexes);
        if (setAppliedIndexes.size() > 0) {
          for (          Index index : setAppliedIndexes) {
            if (strong) {
              strong=index.isStrong();
            }
          }
        }
      }
      if (lsIndexAwarePredicates.size() == 1) {
        IndexAwarePredicate indexAwarePredicate=lsIndexAwarePredicates.get(0);
        return indexAwarePredicate.filter(mapIndexes);
      }
 else       if (lsIndexAwarePredicates.size() > 0) {
        Set<MapEntry> smallestSet=null;
        List<Set<MapEntry>> lsSubResults=new ArrayList<Set<MapEntry>>(lsIndexAwarePredicates.size());
        for (        IndexAwarePredicate indexAwarePredicate : lsIndexAwarePredicates) {
          Set<MapEntry> sub=indexAwarePredicate.filter(mapIndexes);
          if (sub == null || sub.size() == 0) {
            return null;
          }
 else {
            if (smallestSet == null) {
              smallestSet=sub;
            }
 else {
              if (sub.size() < smallestSet.size()) {
                smallestSet=sub;
              }
            }
            lsSubResults.add(sub);
          }
        }
        System.out.println("smallest set size " + smallestSet.size());
        results=new HashSet<MapEntry>();
        results.addAll(smallestSet);
        Iterator<MapEntry> it=results.iterator();
        smallestLoop:         while (it.hasNext()) {
          MapEntry entry=it.next();
          for (          Set<MapEntry> sub : lsSubResults) {
            if (!sub.contains(entry)) {
              it.remove();
              continue smallestLoop;
            }
          }
        }
      }
 else {
        results=new HashSet<MapEntry>();
        results.addAll(ownedRecords);
      }
    }
 else {
      results=new HashSet<MapEntry>();
      results.addAll(ownedRecords);
    }
  }
  finally {
    strongRef.set(strong);
  }
  return results;
}
