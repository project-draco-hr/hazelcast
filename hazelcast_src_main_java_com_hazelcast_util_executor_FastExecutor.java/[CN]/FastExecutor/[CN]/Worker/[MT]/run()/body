{
  final Thread currentThread=Thread.currentThread();
  final boolean take=keepAliveMillis <= 0 || keepAliveMillis == Long.MAX_VALUE;
  final long timeout=keepAliveMillis;
  while (!currentThread.isInterrupted() && live) {
    try {
      final WorkerTask task=take ? queue.take() : queue.poll(timeout,TimeUnit.MILLISECONDS);
      if (task != null) {
        task.run();
      }
 else {
        lock.lockInterruptibly();
        try {
          if (activeThreadCount > coreThreadSize || allowCoreThreadTimeout) {
            threads.remove(currentThread);
            activeThreadCount--;
            final WorkerLifecycleInterceptor workerInterceptor=interceptor;
            if (workerInterceptor != null) {
              workerInterceptor.afterWorkerTerminate();
            }
            return;
          }
        }
  finally {
          lock.unlock();
        }
      }
    }
 catch (    InterruptedException e) {
      break;
    }
  }
}
