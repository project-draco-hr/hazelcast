{
  String[] registrationIds=new String[latches.length];
  WatcherDefinition[] watcherDefinitions=new WatcherDefinition[latches.length];
  for (int i=0; i < replicatedMaps.length; i++) {
    ReplicatedMap<K,V> replicatedMap=replicatedMaps[i];
    CountDownLatch latch=new CountDownLatch(latches[i]);
    WatcherListener<K,V> listener=new WatcherListener<K,V>(latch,eventType);
    watcherDefinitions[i]=new WatcherDefinition(latch);
    registrationIds[i]=replicatedMap.addEntryListener(listener);
  }
  try {
    runnable.run();
    long deadline=TimeUnit.SECONDS.toNanos(timeoutSeconds);
    for (    WatcherDefinition definition : watcherDefinitions) {
      long start=System.nanoTime();
      definition.await(deadline,TimeUnit.NANOSECONDS);
      deadline-=System.nanoTime() - start;
      if (deadline <= 0) {
        throw new TimeoutException("Deadline reached. Remaining: " + definition.latch.getCount());
      }
    }
  }
 catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
 finally {
    for (int i=0; i < replicatedMaps.length; i++) {
      ReplicatedMap replicatedMap=replicatedMaps[i];
      replicatedMap.removeEntryListener(registrationIds[i]);
    }
  }
}
