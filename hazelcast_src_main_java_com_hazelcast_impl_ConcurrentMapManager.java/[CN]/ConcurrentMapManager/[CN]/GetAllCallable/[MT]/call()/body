{
  final ConcurrentMapManager c=factory.node.concurrentMapManager;
  Pairs pairs=new Pairs();
  CMap cmap=c.getMap(mapName);
  if (cmap == null) {
    c.enqueueAndWait(new Processable(){
      public void process(){
        c.getOrCreateMap(mapName);
      }
    }
,100);
    cmap=c.getMap(mapName);
  }
  if (cmap != null) {
    Collection<Object> keysToLoad=(cmap.loader != null) ? new HashSet<Object>() : null;
    Set<Data> missingKeys=new HashSet<Data>(1);
    for (    Data key : keys.getKeys()) {
      boolean exist=false;
      Record record=cmap.getRecord(key);
      if (record != null && record.isActive() && record.isValid()) {
        Data value=record.getValueData();
        if (value != null) {
          pairs.addKeyValue(new KeyValue(key,value));
          record.setLastAccessed();
          exist=true;
        }
      }
      if (!exist) {
        missingKeys.add(key);
        if (keysToLoad != null) {
          keysToLoad.add(toObject(key));
        }
      }
    }
    if (keysToLoad != null && keysToLoad.size() > 0 && cmap.loader != null) {
      final Map<Object,Object> mapLoadedEntries=cmap.loader.loadAll(keysToLoad);
      if (mapLoadedEntries != null) {
        for (        Object key : mapLoadedEntries.keySet()) {
          Data dKey=toData(key);
          Object value=mapLoadedEntries.get(key);
          Data dValue=toData(value);
          if (dKey != null && dValue != null) {
            pairs.addKeyValue(new KeyValue(dKey,dValue));
            c.putTransient(mapName,key,value,0,-1);
          }
 else {
            missingKeys.add(dKey);
          }
        }
      }
    }
    if (cmap.loader == null && !missingKeys.isEmpty()) {
      ThreadContext threadContext=ThreadContext.get();
      CallContext realCallContext=threadContext.getCallContext();
      try {
        threadContext.setCallContext(CallContext.DUMMY_CLIENT);
        MProxy mproxy=(MProxy)factory.getOrCreateProxyByName(mapName);
        for (        Data key : missingKeys) {
          Data value=(Data)mproxy.get(key);
          if (value != null) {
            pairs.addKeyValue(new KeyValue(key,value));
          }
        }
      }
  finally {
        threadContext.setCallContext(realCallContext);
      }
    }
  }
  return pairs;
}
