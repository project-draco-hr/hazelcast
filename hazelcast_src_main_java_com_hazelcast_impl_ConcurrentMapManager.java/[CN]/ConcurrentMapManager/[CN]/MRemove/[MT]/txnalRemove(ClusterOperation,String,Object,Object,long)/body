{
  ThreadContext threadContext=ThreadContext.get();
  TransactionImpl txn=threadContext.getCallContext().getTransaction();
  if (txn != null && txn.getStatus() == Transaction.TXN_STATUS_ACTIVE) {
    if (!txn.has(name,key)) {
      MLock mlock=new MLock();
      boolean locked=mlock.lockAndGetValue(name,key,DEFAULT_TXN_TIMEOUT);
      if (!locked)       throwCME(key);
      Object oldObject=null;
      Data oldValue=mlock.oldValue;
      if (oldValue != null) {
        oldObject=threadContext.toObject(oldValue);
      }
      int removedValueCount=0;
      if (oldObject != null) {
        if (oldObject instanceof CMap.Values) {
          CMap.Values values=(CMap.Values)oldObject;
          removedValueCount=(values == null) ? 0 : values.size();
        }
 else {
          removedValueCount=1;
        }
      }
      txn.attachRemoveOp(name,key,value,(oldObject == null),removedValueCount);
      return oldObject;
    }
 else {
      return txn.attachRemoveOp(name,key,value,false);
    }
  }
 else {
    Object oldValue=objectCall(operation,name,key,value,timeout,-1);
    if (oldValue != null) {
      if (oldValue instanceof AddressAwareException) {
        rethrowException(operation,(AddressAwareException)oldValue);
      }
      backup(CONCURRENT_MAP_BACKUP_REMOVE);
    }
    return oldValue;
  }
}
