{
  CMap cmap=getOrCreateMap(request.name);
  SystemLogService css=systemLogService;
  if (css.shouldLog(TRACE)) {
    css.logObject(request,TRACE,cmap);
  }
  boolean checkCapacity=request.operation != CONCURRENT_MAP_REPLACE_IF_NOT_NULL;
  boolean overCapacity=checkCapacity && cmap.overCapacity();
  boolean cmapNotLocked=cmap.isNotLocked(request);
  if (css.shouldLog(TRACE)) {
    css.trace(request,"OverCapacity/CmapNotLocked",overCapacity,cmapNotLocked);
  }
  if (cmapNotLocked) {
    if (!overCapacity) {
      if (shouldSchedule(request)) {
        if (request.hasEnoughTimeToSchedule()) {
          if (css.shouldLog(INFO)) {
            css.info(request,MapSystemLogFactory.newScheduleRequest(request,cmap.getRecord(request)));
          }
          schedule(request);
        }
 else {
          if (css.shouldLog(INFO)) {
            css.info(request,"NoTimeToSchedule",request.name,request.operation);
          }
          onNoTimeToSchedule(request);
        }
        return;
      }
      Record record=cmap.getRecord(request);
      if (css.shouldLog(TRACE)) {
        css.trace(request,"Record is",record);
      }
      if ((record == null || record.isLoadable()) && cmap.loader != null && request.operation != ClusterOperation.CONCURRENT_MAP_SET) {
        if (css.shouldLog(TRACE)) {
          css.trace(request,"Will Load");
        }
        storeExecutor.execute(new PutLoader(cmap,request),request.key.hashCode());
      }
 else {
        storeProceed(cmap,request);
      }
    }
 else     if (request.operation == CONCURRENT_MAP_TRY_PUT) {
      request.response=Boolean.FALSE;
      returnResponse(request);
    }
 else {
      returnRedoResponse(request,REDO_MAP_OVER_CAPACITY);
    }
  }
 else {
    returnRedoResponse(request,REDO_MAP_LOCKED);
  }
}
