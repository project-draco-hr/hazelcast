{
  final int localBackupCount=backupCount;
  final int localAsyncBackupCount=asyncBackupCount;
  final int totalBackupCount=localBackupCount + localAsyncBackupCount;
  if (localBackupCount <= 0 && localAsyncBackupCount <= 0) {
    return;
  }
  if (totalBackupCount > maxBackupCount) {
    String msg="Max backup is " + maxBackupCount + " but total backupCount is "+ totalBackupCount;
    logger.log(Level.SEVERE,msg);
    throw new HazelcastException(msg);
  }
  if (request.key == null || request.key.size() == 0) {
    throw new HazelcastException("Key is null! " + request.key);
  }
  final MBackup[] backupOps=new MBackup[localBackupCount];
  for (int i=0; i < totalBackupCount; i++) {
    final int replicaIndex=i + 1;
    if (i < localBackupCount) {
      MBackup backupOp=new MBackup();
      backupOps[i]=backupOp;
      backupOp.sendBackup(operation,replicaIndex,request);
    }
 else {
      final Request reqBackup=Request.copyFromRequest(request);
      reqBackup.operation=operation;
      enqueueAndReturn(new AsyncBackupProcessable(reqBackup,replicaIndex));
    }
  }
  for (int i=0; i < localBackupCount; i++) {
    MBackup backupOp=backupOps[i];
    try {
      if (!backupOp.getResultAsBoolean()) {
        if (logger.isLoggable(Level.FINEST)) {
          logger.log(Level.FINEST,"Backup failed -> " + request);
        }
      }
    }
 catch (    HazelcastException e) {
      final Level level=backupRedoEnabled ? Level.WARNING : Level.FINEST;
      logger.log(level,"Backup operation [" + operation + "] has failed! "+ e.getClass().getName()+ ": "+ e.getMessage());
      logger.log(Level.FINEST,e.getMessage(),e);
    }
  }
}
