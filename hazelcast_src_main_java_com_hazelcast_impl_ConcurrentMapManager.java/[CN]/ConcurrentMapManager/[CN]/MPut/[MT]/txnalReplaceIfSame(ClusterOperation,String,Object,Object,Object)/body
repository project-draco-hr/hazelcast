{
  ThreadContext threadContext=ThreadContext.get();
  TransactionImpl txn=threadContext.getCallContext().getTransaction();
  if (txn != null && txn.getStatus() == Transaction.TXN_STATUS_ACTIVE) {
    if (!txn.has(name,key)) {
      MLock mlock=new MLock();
      boolean locked=mlock.lockAndGetValue(name,key,DEFAULT_TXN_TIMEOUT);
      if (!locked) {
        throwTxTimeoutException(key);
      }
      Object oldObject=null;
      Data oldValue=mlock.oldValue;
      if (oldValue != null) {
        oldObject=threadContext.isClient() ? oldValue : threadContext.toObject(oldValue);
      }
      if (oldObject == null) {
        return Boolean.FALSE;
      }
 else {
        if (expectedValue.equals(oldObject)) {
          txn.attachPutOp(name,key,toData(newValue),false);
          return Boolean.TRUE;
        }
 else {
          return Boolean.FALSE;
        }
      }
    }
 else {
      if (expectedValue.equals(toObject(txn.get(name,key)))) {
        txn.attachPutOp(name,key,toData(newValue),false);
        return Boolean.TRUE;
      }
 else {
        return Boolean.FALSE;
      }
    }
  }
 else {
    Data dataExpected=toData(expectedValue);
    Data dataNew=toData(newValue);
    setLocal(operation,name,key,new MultiData(dataExpected,dataNew),-1,-1);
    request.longValue=(request.value == null) ? Integer.MIN_VALUE : dataNew.hashCode();
    setIndexValues(request,newValue);
    request.setBooleanRequest();
    final Data realValue=request.value;
    doOp();
    Object returnObject=getResultAsBoolean();
    if (!Boolean.FALSE.equals(returnObject)) {
      request.value=dataNew;
      backup(CONCURRENT_MAP_BACKUP_PUT,realValue);
    }
    return returnObject;
  }
}
