{
  logger.log(Level.FINEST,"startAsyncStoreWrite " + setDirtyRecords.size());
  long now=System.currentTimeMillis();
  Iterator<Record> itDirtyRecords=setDirtyRecords.iterator();
  final Map<Data,Data> entriesToStore=new HashMap<Data,Data>();
  final Collection<Data> keysToDelete=new HashSet<Data>();
  while (itDirtyRecords.hasNext()) {
    Record dirtyRecord=itDirtyRecords.next();
    if (dirtyRecord.writeTime > now) {
      if (dirtyRecord.getValue() != null) {
        entriesToStore.put(doHardCopy(dirtyRecord.getKey()),doHardCopy(dirtyRecord.getValue()));
      }
 else {
        keysToDelete.add(doHardCopy(dirtyRecord.getKey()));
      }
      dirtyRecord.dirty=false;
      itDirtyRecords.remove();
    }
  }
  final int entriesToStoreSize=entriesToStore.size();
  final int keysToDeleteSize=keysToDelete.size();
  if (entriesToStoreSize > 0 || keysToDeleteSize > 0) {
    executeLocally(new Runnable(){
      public void run(){
        if (keysToDeleteSize > 0) {
          if (keysToDeleteSize == 1) {
            Data key=keysToDelete.iterator().next();
            store.delete(toObject(key));
          }
 else {
            Collection realKeys=new HashSet();
            for (            Data key : keysToDelete) {
              realKeys.add(toObject(key));
            }
            store.deleteAll(realKeys);
          }
        }
        if (entriesToStoreSize > 0) {
          Object keyFirst=null;
          Object valueFirst=null;
          Set<Map.Entry<Data,Data>> entries=entriesToStore.entrySet();
          Map realEntries=new HashMap();
          for (          Map.Entry<Data,Data> entry : entries) {
            Object key=toObject(entry.getKey());
            Object value=toObject(entry.getValue());
            realEntries.put(key,value);
            if (keyFirst == null) {
              keyFirst=key;
              valueFirst=value;
            }
          }
          if (entriesToStoreSize == 1) {
            store.store(keyFirst,valueFirst);
          }
 else {
            store.storeAll(realEntries);
          }
        }
      }
    }
);
  }
}
