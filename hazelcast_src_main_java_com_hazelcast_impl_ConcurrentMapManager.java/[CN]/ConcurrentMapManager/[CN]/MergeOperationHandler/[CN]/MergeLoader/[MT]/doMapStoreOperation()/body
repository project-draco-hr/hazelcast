{
  Object winner=null;
  success=false;
  if (cmap.mergePolicy != null) {
    if (existingRecord == null && cmap.loader != null) {
      existingRecord=new MGetDataRecordEntry().get(request.name,request.key);
    }
    DataRecordEntry newEntry=(DataRecordEntry)toObject(request.value);
    Object key=newEntry.getKey();
    if (key != null && newEntry.hasValue()) {
      winner=cmap.mergePolicy.merge(cmap.getName(),newEntry,existingRecord);
      if (winner != null) {
        if (cmap.isMultiMap()) {
          if (winner == MergePolicy.REMOVE_EXISTING) {
            logger.log(Level.FINER,String.format("Merge policy %s decided to REMOVE_EXISTING for key %s in map %s!",cmap.mergePolicy.getClass().getSimpleName(),cmap.getName(),key));
            MRemoveMulti mremove=node.concurrentMapManager.new MRemoveMulti();
            mremove.remove(request.name,request.key);
          }
 else {
            MPutMulti mput=node.concurrentMapManager.new MPutMulti();
            mput.put(request.name,request.key,winner);
          }
        }
 else {
          if (winner == MergePolicy.REMOVE_EXISTING) {
            logger.log(Level.FINER,String.format("Merge policy %s decided to REMOVE_EXISTING for key %s in map %s!",cmap.mergePolicy.getClass().getSimpleName(),cmap.getName(),key));
            MRemove mremove=node.concurrentMapManager.new MRemove();
            mremove.remove(request.name,request.key);
          }
 else {
            ConcurrentMapManager.MPut mput=node.concurrentMapManager.new MPut();
            mput.put(request.name,request.key,winner,-1);
          }
        }
        success=true;
      }
    }
  }
}
