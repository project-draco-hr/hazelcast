{
  final int groupSize=groups.size();
  final int replicaCount=Math.min(groupSize,PartitionInfo.MAX_REPLICA_COUNT);
  final int avgPartitionPerGroup=partitionCount / groupSize;
  final int maxPartitionPerGroup=avgPartitionPerGroup + 1;
  for (  NodeGroup nodeGroup : groups) {
    nodeGroup.resetPartitions();
  }
  for (  PartitionInfo partition : state) {
    for (int index=0; index < PartitionInfo.MAX_REPLICA_COUNT; index++) {
      if (index >= replicaCount) {
        partition.setReplicaAddress(index,null);
      }
 else {
        final Address owner=partition.getReplicaAddress(index);
        boolean valid=false;
        if (owner != null) {
          for (          NodeGroup nodeGroup : groups) {
            if (nodeGroup.hasNode(owner)) {
              valid=true;
              nodeGroup.ownPartition(owner,index,partition.getPartitionId());
              break;
            }
          }
        }
        if (!valid) {
          partition.setReplicaAddress(index,null);
        }
      }
    }
  }
  for (int index=0; index < replicaCount; index++) {
    final LinkedList<Integer> freePartitions=new LinkedList<Integer>();
    final LinkedList<NodeGroup> underLoadedGroups=new LinkedList<NodeGroup>();
    final LinkedList<NodeGroup> overLoadedGroups=new LinkedList<NodeGroup>();
    int remainingPartitions=partitionCount - avgPartitionPerGroup * groupSize;
    for (    PartitionInfo partition : state) {
      if (partition.getReplicaAddress(index) == null) {
        freePartitions.add(partition.getPartitionId());
      }
    }
    Collections.shuffle(freePartitions);
    for (    NodeGroup nodeGroup : groups) {
      int size=nodeGroup.getPartitonCount(index);
      if (size < avgPartitionPerGroup) {
        underLoadedGroups.add(nodeGroup);
      }
 else       if (size > avgPartitionPerGroup) {
        overLoadedGroups.add(nodeGroup);
      }
    }
    int maxTries=freePartitions.size() * underLoadedGroups.size();
    int tries=0;
    while (tries++ < maxTries && !freePartitions.isEmpty() && !underLoadedGroups.isEmpty()) {
      NodeGroup group=underLoadedGroups.poll();
      int size=freePartitions.size();
      for (int i=0; i < size; i++) {
        Integer partitionId=freePartitions.poll();
        if (!group.addPartition(index,partitionId)) {
          freePartitions.offer(partitionId);
        }
 else {
          break;
        }
      }
      int count=group.getPartitonCount(index);
      if (remainingPartitions > 0 && count == maxPartitionPerGroup) {
        if (--remainingPartitions == 0) {
          Iterator<NodeGroup> underLoaded=underLoadedGroups.iterator();
          while (underLoaded.hasNext()) {
            if (underLoaded.next().getPartitonCount(index) >= avgPartitionPerGroup) {
              underLoaded.remove();
            }
          }
        }
      }
 else       if ((remainingPartitions > 0 && count < maxPartitionPerGroup) || (count < avgPartitionPerGroup)) {
        underLoadedGroups.offer(group);
      }
    }
{
      maxTries=freePartitions.size() * groupSize * 10;
      tries=0;
      Integer partitionId=freePartitions.poll();
      while (partitionId != null && tries++ < maxTries) {
        NodeGroup group=groups.poll();
        if (group.addPartition(index,partitionId)) {
          partitionId=freePartitions.poll();
        }
        groups.offer(group);
      }
    }
    maxTries=underLoadedGroups.size() * overLoadedGroups.size() * 10;
    tries=0;
    int expectedPartitionCount=remainingPartitions > 0 ? maxPartitionPerGroup : avgPartitionPerGroup;
    while (tries++ < maxTries && !underLoadedGroups.isEmpty()) {
      NodeGroup toGroup=underLoadedGroups.poll();
      Iterator<NodeGroup> overLoadedGroupsIter=overLoadedGroups.iterator();
      while (overLoadedGroupsIter.hasNext()) {
        NodeGroup fromGroup=overLoadedGroupsIter.next();
        final Iterator<Integer> partitionsIter=fromGroup.getPartitionsIterator(index);
        while (partitionsIter.hasNext() && fromGroup.getPartitonCount(index) > expectedPartitionCount && toGroup.getPartitonCount(index) < expectedPartitionCount) {
          Integer partitionId=partitionsIter.next();
          if (toGroup.addPartition(index,partitionId)) {
            partitionsIter.remove();
          }
        }
        int fromCount=fromGroup.getPartitonCount(index);
        if (remainingPartitions > 0 && fromCount == maxPartitionPerGroup) {
          if (--remainingPartitions == 0) {
            expectedPartitionCount=avgPartitionPerGroup;
          }
        }
        if (fromCount <= expectedPartitionCount) {
          overLoadedGroupsIter.remove();
        }
        int toCount=toGroup.getPartitonCount(index);
        if (remainingPartitions > 0 && toCount == maxPartitionPerGroup) {
          if (--remainingPartitions == 0) {
            expectedPartitionCount=avgPartitionPerGroup;
          }
        }
        if (toCount >= expectedPartitionCount) {
          break;
        }
      }
      if (toGroup.getPartitonCount(index) < avgPartitionPerGroup) {
        underLoadedGroups.offer(toGroup);
      }
    }
    for (    NodeGroup group : groups) {
      group.postProcessPartitionTable(index);
      for (      Address address : group.getNodes()) {
        PartitionTable table=group.getPartitionTable(address);
        Set<Integer> set=table.getPartitions(index);
        for (        Integer partitionId : set) {
          state[partitionId.intValue()].setReplicaAddress(index,address);
        }
      }
    }
  }
}
