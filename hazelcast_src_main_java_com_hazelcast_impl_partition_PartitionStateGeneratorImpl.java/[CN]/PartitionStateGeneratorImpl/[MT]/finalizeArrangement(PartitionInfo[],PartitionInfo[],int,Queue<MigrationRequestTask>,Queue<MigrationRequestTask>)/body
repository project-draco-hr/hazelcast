{
  final int partitionCount=currentState.length;
  for (int partitionId=0; partitionId < partitionCount; partitionId++) {
    PartitionInfo currentPartition=currentState[partitionId];
    PartitionInfo newPartition=newState[partitionId];
    boolean lost=false;
    for (int replicaIndex=0; replicaIndex < replicaCount; replicaIndex++) {
      Address currentOwner=currentPartition.getReplicaAddress(replicaIndex);
      Address newOwner=newPartition.getReplicaAddress(replicaIndex);
      MigrationRequestTask migrationRequestTask=null;
      if (currentOwner != null && newOwner != null && !currentOwner.equals(newOwner)) {
        migrationRequestTask=new MigrationRequestTask(partitionId,currentOwner,newOwner,replicaIndex,true);
      }
 else       if (currentOwner == null && newOwner != null) {
        if ((currentOwner=currentPartition.getOwner()) == null) {
          lost=true;
        }
        migrationRequestTask=new MigrationRequestTask(partitionId,currentOwner,newOwner,replicaIndex,false);
      }
 else       if (currentOwner != null && newOwner == null) {
        logger.log(Level.WARNING,"Something seems wrong! Old owner is valid but new owner is null!");
      }
      if (migrationRequestTask != null) {
        boolean immediate=false;
        if (replicaIndex == 0 && currentPartition.getOwner() != null && currentPartition.getOwner().equals(newPartition.getReplicaAddress(1))) {
          immediate=true;
        }
 else         if (replicaIndex == 1 && currentPartition.getReplicaAddress(1) == null) {
          immediate=true;
        }
        if (immediate) {
          immediateQueue.offer(migrationRequestTask);
        }
 else {
          scheduledQueue.offer(migrationRequestTask);
        }
      }
    }
    if (lost) {
      logger.log(Level.SEVERE,"Oops! " + currentPartition + " has been LOST!");
    }
  }
}
