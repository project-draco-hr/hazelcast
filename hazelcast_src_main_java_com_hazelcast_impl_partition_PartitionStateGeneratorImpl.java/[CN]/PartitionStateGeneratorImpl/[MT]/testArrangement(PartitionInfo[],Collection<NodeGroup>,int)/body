{
  final float ratio=RANGE_CHECK_RATIO;
  final int avgPartitionPerGroup=partitionCount / groups.size();
  final int replicaCount=Math.min(groups.size(),PartitionInfo.MAX_REPLICA_COUNT);
  final Set<Address> set=new HashSet<Address>();
  for (  PartitionInfo p : state) {
    for (int i=0; i < replicaCount; i++) {
      Address owner=p.getReplicaAddress(i);
      if (owner == null) {
        logger.log(Level.WARNING,"Partition-Arrangement-Test: Owner is null !!! => partition: " + p.getPartitionId() + " replica: "+ i);
        return TestResult.FAIL;
      }
      if (set.contains(owner)) {
        logger.log(Level.WARNING,"Partition-Arrangement-Test: " + owner + " has owned multiple replicas of partition: "+ p.getPartitionId()+ " replica: "+ i);
        return TestResult.FAIL;
      }
      set.add(owner);
    }
    set.clear();
  }
  for (  NodeGroup group : groups) {
    for (int i=0; i < replicaCount; i++) {
      int partitionCountOfGroup=group.getPartitionCount(i);
      if ((partitionCountOfGroup < avgPartitionPerGroup / ratio) || (partitionCountOfGroup > avgPartitionPerGroup * ratio)) {
        logger.log(Level.FINEST,"Replica: " + i + ", PartitionCount: "+ partitionCountOfGroup+ ", AvgPartitionCount: "+ avgPartitionPerGroup);
        return TestResult.RETRY;
      }
    }
  }
  return TestResult.PASS;
}
