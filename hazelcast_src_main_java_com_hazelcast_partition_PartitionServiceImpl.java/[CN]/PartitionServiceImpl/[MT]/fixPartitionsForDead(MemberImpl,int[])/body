{
  if (node.isMaster() && node.isActive()) {
    lock.lock();
    try {
      sendingDiffs.set(true);
      logger.log(Level.INFO,"Starting to send partition replica diffs...");
      int diffCount=0;
      for (int partitionId=0; partitionId < indexesOfDead.length; partitionId++) {
        final int indexOfDead=indexesOfDead[partitionId];
        if (indexOfDead != -1) {
          final PartitionInfo partition=partitions[partitionId];
          final Address owner=partition.getOwner();
          if (owner == null) {
            logger.log(Level.FINEST,"Owner of one of the replicas of Partition[" + partitionId + "] is dead, but partition owner could not be found either!");
            logger.log(Level.FINEST,partition.toString());
            continue;
          }
          for (int replicaIndex=indexOfDead; replicaIndex < PartitionInfo.MAX_REPLICA_COUNT; replicaIndex++) {
            final Address target=partition.getReplicaAddress(replicaIndex);
            if (target != null && !target.equals(owner)) {
              if (getMember(target) != null) {
                immediateTasksQueue.offer(new Migrator(new MigrationInfo(partitionId,replicaIndex,MigrationType.COPY,owner,target)));
                diffCount++;
              }
 else {
                logger.log(Level.WARNING,"Target member of replica diff task couldn't found! " + "Replica: " + replicaIndex + ", Dead: "+ deadMember+ "\n"+ partition);
              }
            }
          }
        }
      }
      sendPartitionRuntimeState();
      final int totalDiffCount=diffCount;
      immediateTasksQueue.offer(new Runnable(){
        public void run(){
          logger.log(Level.INFO,"Total " + totalDiffCount + " partition replica diffs have been processed.");
          sendingDiffs.set(false);
        }
      }
);
      immediateTasksQueue.offer(new PrepareRepartitioningTask());
    }
  finally {
      lock.unlock();
    }
  }
}
