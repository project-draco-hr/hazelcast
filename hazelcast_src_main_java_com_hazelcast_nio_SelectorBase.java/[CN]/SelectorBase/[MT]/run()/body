{
  try {
    connectionManager.ioService.onIOThreadStart();
    while (live) {
      threadWatcher.incrementRunCount();
      long currentMillis=System.currentTimeMillis();
      if ((currentMillis - lastPublish) > TEN_SECOND_MILLIS) {
        publishUtilization();
        lastPublish=currentMillis;
      }
      processSelectionQueue();
      if (!live)       return;
      int selectedKeyCount;
      try {
        long startWait=System.nanoTime();
        selectedKeyCount=selector.select(waitTime);
        long now=System.nanoTime();
        threadWatcher.addWait((now - startWait),now);
        if (Thread.interrupted()) {
          connectionManager.ioService.handleInterruptedException(Thread.currentThread(),new RuntimeException());
          return;
        }
      }
 catch (      Throwable exp) {
        continue;
      }
      if (selectedKeyCount == 0) {
        continue;
      }
      final Set<SelectionKey> setSelectedKeys=selector.selectedKeys();
      final Iterator<SelectionKey> it=setSelectedKeys.iterator();
      while (it.hasNext()) {
        final SelectionKey sk=it.next();
        try {
          it.remove();
          if (sk.isValid() && sk.isReadable()) {
            Connection connection=(Connection)sk.attachment();
            connection.getReadHandler().handle();
          }
          if (sk.isValid() && sk.isWritable()) {
            sk.interestOps(sk.interestOps() & ~SelectionKey.OP_WRITE);
            Connection connection=(Connection)sk.attachment();
            connection.getWriteHandler().handle();
          }
          if (sk.isValid() && sk.isConnectable()) {
            sk.interestOps(sk.interestOps() & ~SelectionKey.OP_CONNECT);
            SelectionHandler selectionHandler=(SelectionHandler)sk.attachment();
            selectionHandler.handle();
          }
          if (sk.isValid() && sk.isAcceptable()) {
            SelectionHandler selectionHandler=(SelectionHandler)sk.attachment();
            selectionHandler.handle();
          }
        }
 catch (        Throwable e) {
          handleSelectorException(e);
        }
      }
    }
  }
 catch (  OutOfMemoryError e) {
    connectionManager.ioService.onOutOfMemory(e);
  }
catch (  Throwable e) {
    logger.log(Level.WARNING,"unhandled exception in " + Thread.currentThread().getName(),e);
  }
 finally {
    try {
      logger.log(Level.FINE,"closing selector " + Thread.currentThread().getName());
      selector.close();
    }
 catch (    final Exception ignored) {
    }
  }
}
