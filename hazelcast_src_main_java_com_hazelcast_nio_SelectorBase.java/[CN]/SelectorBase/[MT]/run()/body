{
  try {
    ThreadContext.get().setCurrentFactory(node.factory);
    while (live) {
      threadWatcher.incrementRunCount();
      long currentMillis=System.currentTimeMillis();
      if ((currentMillis - lastPublish) > TEN_SECOND_MILLIS) {
        publishUtilization();
        lastPublish=currentMillis;
      }
      processSelectionQueue();
      if (!live)       return;
      int selectedKeyCount;
      try {
        long startWait=System.nanoTime();
        selectedKeyCount=selector.select(waitTime);
        long now=System.nanoTime();
        threadWatcher.addWait((now - startWait),now);
        if (Thread.interrupted()) {
          node.handleInterruptedException(Thread.currentThread(),new RuntimeException());
          return;
        }
      }
 catch (      Throwable exp) {
        continue;
      }
      if (selectedKeyCount == 0) {
        continue;
      }
      final Set<SelectionKey> setSelectedKeys=selector.selectedKeys();
      final Iterator<SelectionKey> it=setSelectedKeys.iterator();
      while (it.hasNext()) {
        final SelectionKey sk=it.next();
        try {
          it.remove();
          if (sk.isValid()) {
            if (sk.isReadable()) {
              Connection connection=(Connection)sk.attachment();
              connection.getReadHandler().handle();
            }
            if (sk.isWritable()) {
              sk.interestOps(sk.interestOps() & ~SelectionKey.OP_WRITE);
              Connection connection=(Connection)sk.attachment();
              connection.getWriteHandler().handle();
            }
            if (sk.isConnectable()) {
              sk.interestOps(sk.interestOps() & ~SelectionKey.OP_CONNECT);
              SelectionHandler selectionHandler=(SelectionHandler)sk.attachment();
              selectionHandler.handle();
            }
            if (sk.isAcceptable()) {
              SelectionHandler selectionHandler=(SelectionHandler)sk.attachment();
              selectionHandler.handle();
            }
          }
        }
 catch (        Throwable e) {
          e.printStackTrace();
          handleSelectorException(e);
        }
      }
    }
  }
 catch (  OutOfMemoryError e) {
    node.onOutOfMemory(e);
  }
catch (  Throwable e) {
    logger.log(Level.WARNING,"unhandled exception in " + Thread.currentThread().getName(),e);
  }
 finally {
    try {
      logger.log(Level.FINE,"closing selector " + Thread.currentThread().getName());
      selector.close();
    }
 catch (    final Exception ignored) {
    }
  }
}
