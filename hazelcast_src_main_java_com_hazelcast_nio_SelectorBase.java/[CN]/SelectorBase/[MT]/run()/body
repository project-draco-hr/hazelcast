{
  try {
    while (live) {
      if (threadWatcher.incrementRunCount() % 10000 == 0) {
        publishUtilization();
      }
      processSelectionQueue();
      if (!live)       return;
      int selectedKeyCount;
      try {
        long startWait=System.nanoTime();
        selectedKeyCount=selector.select(waitTime);
        long now=System.nanoTime();
        threadWatcher.addWait((now - startWait),now);
        if (Thread.interrupted()) {
          node.handleInterruptedException(Thread.currentThread(),new RuntimeException());
          return;
        }
      }
 catch (      Throwable exp) {
        continue;
      }
      if (selectedKeyCount == 0) {
        continue;
      }
      final Set<SelectionKey> setSelectedKeys=selector.selectedKeys();
      final Iterator<SelectionKey> it=setSelectedKeys.iterator();
      while (it.hasNext()) {
        final SelectionKey sk=it.next();
        it.remove();
        try {
          sk.interestOps(sk.interestOps() & ~sk.readyOps());
          SelectionHandler selectionHandler=(SelectionHandler)sk.attachment();
          selectionHandler.handle();
        }
 catch (        CancelledKeyException e) {
        }
catch (        Throwable e) {
          handleSelectorException(e);
        }
      }
    }
  }
 catch (  OutOfMemoryError e) {
    node.onOutOfMemory(e);
  }
catch (  Throwable e) {
    logger.log(Level.WARNING,"unhandled exception in " + Thread.currentThread().getName(),e);
  }
 finally {
    try {
      logger.log(Level.FINE,"closing selector " + Thread.currentThread().getName());
      selector.close();
    }
 catch (    final Exception ignored) {
    }
  }
}
