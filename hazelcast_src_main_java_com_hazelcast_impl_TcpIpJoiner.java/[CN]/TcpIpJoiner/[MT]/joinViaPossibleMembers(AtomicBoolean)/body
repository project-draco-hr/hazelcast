{
  try {
    node.getFailedConnections().clear();
    final Collection<Address> colPossibleAddresses=getPossibleMembers(config,node.address,logger);
    colPossibleAddresses.remove(node.address);
    for (    final Address possibleAddress : colPossibleAddresses) {
      logger.log(Level.INFO,"connecting to " + possibleAddress);
      node.connectionManager.getOrConnect(possibleAddress);
    }
    boolean found=false;
    int numberOfSeconds=0;
    final int connectionTimeoutSeconds=config.getNetworkConfig().getJoin().getTcpIpConfig().getConnectionTimeoutSeconds();
    while (!found && numberOfSeconds < connectionTimeoutSeconds) {
      colPossibleAddresses.removeAll(node.getFailedConnections());
      if (colPossibleAddresses.size() == 0) {
        break;
      }
      Thread.sleep(1000L);
      numberOfSeconds++;
      int numberOfJoinReq=0;
      logger.log(Level.FINEST,"we are going to try to connect to each address, but no more than five times");
      for (      Address possibleAddress : colPossibleAddresses) {
        logger.log(Level.FINEST,"connection attempt " + numberOfJoinReq + " to "+ possibleAddress);
        final Connection conn=node.connectionManager.getOrConnect(possibleAddress);
        if (conn != null && numberOfJoinReq < 5) {
          found=true;
          logger.log(Level.FINEST,"found and sending join request for " + possibleAddress);
          node.clusterManager.sendJoinRequest(possibleAddress);
          numberOfJoinReq++;
        }
 else {
          logger.log(Level.FINEST,"number of join requests is greater than 5, no join request will be sent for " + possibleAddress);
        }
      }
    }
    logger.log(Level.FINEST,"FOUND " + found);
    if (!found) {
      logger.log(Level.FINEST,"This node will assume master role since no possible member where connected to");
      node.setAsMaster();
    }
 else {
      while (!joined.get()) {
        int maxTryCount=3;
        for (        Address possibleAddress : colPossibleAddresses) {
          if (node.address.hashCode() > possibleAddress.hashCode()) {
            maxTryCount=6;
            break;
          }
 else           if (node.address.hashCode() == possibleAddress.hashCode()) {
            maxTryCount=3 + ((int)(Math.random() * 10));
            break;
          }
        }
        int tryCount=0;
        while (tryCount++ < maxTryCount && (node.getMasterAddress() == null)) {
          connectAndSendJoinRequest(colPossibleAddresses);
          Thread.sleep(1000L);
        }
        int requestCount=0;
        while (node.getMasterAddress() != null && !joined.get()) {
          Thread.sleep(1000L);
          node.clusterManager.sendJoinRequest(node.getMasterAddress());
          if (requestCount++ > 22) {
            failedJoiningToMaster(false,requestCount);
          }
        }
        if (node.getMasterAddress() == null) {
          boolean masterCandidate=true;
          for (          Address address : colPossibleAddresses) {
            if (node.address.hashCode() > address.hashCode()) {
              masterCandidate=false;
            }
          }
          if (masterCandidate) {
            logger.log(Level.FINEST,"I am the master candidate, setting as master");
            node.setAsMaster();
          }
        }
      }
    }
    colPossibleAddresses.clear();
    node.getFailedConnections().clear();
  }
 catch (  Throwable t) {
    logger.log(Level.SEVERE,t.getMessage(),t);
  }
}
