{
  try {
    node.getFailedConnections().clear();
    final Collection<Address> colPossibleAddresses=getPossibleMembers(config,node.address,logger);
    colPossibleAddresses.remove(node.address);
    for (    final Address possibleAddress : colPossibleAddresses) {
      logger.log(Level.INFO,"connecting to " + possibleAddress);
      node.connectionManager.getOrConnect(possibleAddress);
    }
    boolean foundConnection=false;
    int numberOfSeconds=0;
    final int connectionTimeoutSeconds=config.getNetworkConfig().getJoin().getTcpIpConfig().getConnectionTimeoutSeconds();
    while (!foundConnection && numberOfSeconds < connectionTimeoutSeconds) {
      colPossibleAddresses.removeAll(node.getFailedConnections());
      if (colPossibleAddresses.size() == 0) {
        break;
      }
      Thread.sleep(1000L);
      numberOfSeconds++;
      logger.log(Level.FINEST,"we are going to try to connect to each address");
      for (      Address possibleAddress : colPossibleAddresses) {
        final Connection conn=node.connectionManager.getOrConnect(possibleAddress);
        if (conn != null) {
          foundConnection=true;
          logger.log(Level.FINEST,"found and sending join request for " + possibleAddress);
          node.clusterManager.sendJoinRequest(possibleAddress,true);
        }
      }
    }
    logger.log(Level.FINEST,"FOUND " + foundConnection);
    if (!foundConnection) {
      logger.log(Level.FINEST,"This node will assume master role since no possible member where connected to");
      node.setAsMaster();
    }
 else {
      if (!node.joined()) {
        if (connectionTimeoutSeconds - numberOfSeconds > 0) {
          logger.log(Level.FINEST,"Sleeping for " + (connectionTimeoutSeconds - numberOfSeconds) + " seconds.");
          Thread.sleep((connectionTimeoutSeconds - numberOfSeconds) * 1000L);
        }
        colPossibleAddresses.removeAll(node.getFailedConnections());
        if (colPossibleAddresses.size() == 0) {
          logger.log(Level.FINEST,"This node will assume master role since all possible members didn't accept join request");
          node.setAsMaster();
        }
 else {
          boolean masterCandidate=true;
          for (          Address address : colPossibleAddresses) {
            if (node.connectionManager.getConnection(address) != null) {
              if (node.address.hashCode() > address.hashCode()) {
                masterCandidate=false;
              }
            }
          }
          if (masterCandidate) {
            askingForApproval=true;
            for (            Address address : colPossibleAddresses) {
              Connection conn=node.getConnectionManager().getConnection(address);
              if (conn != null) {
                responseCounter.incrementAndGet();
                node.clusterManager.sendProcessableTo(new MasterQuestion(),conn);
              }
            }
            int waitCount=0;
            while (node.isActive() && waitCount++ < 10) {
              Thread.sleep(1000L);
              if (responseCounter.get() == 0) {
                if (approved) {
                  logger.log(Level.FINEST,node.getThisAddress() + " Setting myself as master! group " + node.getConfig().getGroupConfig().getName()+ " possible addresses "+ colPossibleAddresses.size()+ ""+ colPossibleAddresses);
                  node.setAsMaster();
                  return;
                }
 else {
                  lookForMaster(colPossibleAddresses);
                  break;
                }
              }
            }
          }
 else {
            lookForMaster(colPossibleAddresses);
          }
        }
      }
    }
    colPossibleAddresses.clear();
    node.getFailedConnections().clear();
  }
 catch (  Throwable t) {
    logger.log(Level.SEVERE,t.getMessage(),t);
  }
}
