{
  try {
    node.getFailedConnections().clear();
    final Collection<Address> colPossibleAddresses=getPossibleMembers(config,node.address,logger);
    colPossibleAddresses.remove(node.address);
    for (    final Address possibleAddress : colPossibleAddresses) {
      logger.log(Level.INFO,"connecting to " + possibleAddress);
      node.connectionManager.getOrConnect(possibleAddress);
    }
    boolean foundConnection=false;
    int numberOfSeconds=0;
    final int connectionTimeoutSeconds=config.getNetworkConfig().getJoin().getTcpIpConfig().getConnectionTimeoutSeconds();
    while (!foundConnection && numberOfSeconds < connectionTimeoutSeconds) {
      colPossibleAddresses.removeAll(node.getFailedConnections());
      if (colPossibleAddresses.size() == 0) {
        break;
      }
      Thread.sleep(1000L);
      numberOfSeconds++;
      logger.log(Level.FINEST,"we are going to try to connect to each address, but no more than five times");
      for (      Address possibleAddress : colPossibleAddresses) {
        final Connection conn=node.connectionManager.getOrConnect(possibleAddress);
        if (conn != null) {
          foundConnection=true;
          logger.log(Level.FINEST,"found and sending join request for " + possibleAddress);
          node.clusterManager.sendJoinRequest(possibleAddress);
        }
      }
    }
    logger.log(Level.FINEST,"FOUND " + foundConnection);
    if (!foundConnection) {
      logger.log(Level.FINEST,"This node will assume master role since no possible member where connected to");
      node.setAsMaster();
    }
 else {
      if (!node.joined()) {
        boolean masterCandidate=true;
        for (        Address address : colPossibleAddresses) {
          if (node.address.hashCode() > address.hashCode()) {
            masterCandidate=false;
          }
        }
        if (masterCandidate) {
          askingForApproval=true;
          for (          Address address : colPossibleAddresses) {
            Connection conn=node.getConnectionManager().getConnection(address);
            if (conn != null) {
              responseCounter.incrementAndGet();
              node.clusterManager.sendProcessableTo(new MasterQuestion(),conn);
            }
          }
          int waitCount=0;
          while (waitCount++ < 10) {
            Thread.sleep(1000L);
            System.out.println(node.getThisAddress() + " resCoun  " + responseCounter.get()+ " ... "+ approved);
            if (responseCounter.get() == 0) {
              if (approved) {
                node.setAsMaster();
                return;
              }
 else {
                lookForMaster(colPossibleAddresses);
                break;
              }
            }
          }
        }
 else {
          lookForMaster(colPossibleAddresses);
        }
      }
    }
    colPossibleAddresses.clear();
    node.getFailedConnections().clear();
  }
 catch (  Throwable t) {
    logger.log(Level.SEVERE,t.getMessage(),t);
  }
}
