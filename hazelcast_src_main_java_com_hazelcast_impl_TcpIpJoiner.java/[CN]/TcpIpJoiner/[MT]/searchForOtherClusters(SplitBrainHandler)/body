{
  final Collection<Address> colPossibleAddresses;
  try {
    colPossibleAddresses=getPossibleAddresses();
  }
 catch (  Throwable e) {
    logger.log(Level.SEVERE,e.getMessage(),e);
    return;
  }
  colPossibleAddresses.remove(node.getThisAddress());
  for (  Member member : node.getClusterImpl().getMembers()) {
    colPossibleAddresses.remove(((MemberImpl)member).getAddress());
  }
  if (colPossibleAddresses.size() == 0) {
    return;
  }
  for (  final Address possibleAddress : colPossibleAddresses) {
    logger.log(Level.FINEST,node.getThisAddress() + " is connecting to " + possibleAddress);
    node.connectionManager.getOrConnect(possibleAddress);
  }
  for (  Address possibleAddress : colPossibleAddresses) {
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
      return;
    }
    final Connection conn=node.connectionManager.getConnection(possibleAddress);
    if (conn != null) {
      final JoinInfo response=node.clusterManager.checkJoin(conn);
      if (response != null && shouldMerge(response)) {
        logger.log(Level.WARNING,node.address + " is merging [tcp/ip] to " + possibleAddress);
        splitBrainHandler.restart();
      }
      return;
    }
  }
}
