{
  clusterPartitionRegistry.reset();
  for (  MemberImpl member : members) {
    clusterPartitionRegistry.init(member.getAddress());
  }
  final int nodeSize=members.size();
  final int replicaCount=clusterPartitionRegistry.getMaxReplicaCount();
  final int avgPartitionPerNode=partitionCount / nodeSize;
  final Random rand=new Random();
  if (replicaCount < PartitionInfo.MAX_REPLICA_COUNT) {
    for (    PartitionInfo partition : state) {
      for (int index=replicaCount - 1; index < PartitionInfo.MAX_REPLICA_COUNT; index++) {
        partition.setReplicaAddress(index,null);
      }
    }
  }
  for (  PartitionInfo partition : state) {
    Address owner=null;
    for (int index=0; index < replicaCount; index++) {
      if ((owner=partition.getReplicaAddress(index)) != null) {
        clusterPartitionRegistry.register(owner,partition.getPartitionId());
      }
    }
  }
  for (int index=0; index < replicaCount; index++) {
    final LinkedList<Integer> partitionsToArrange=new LinkedList<Integer>();
    int maxPartitionPerNode=avgPartitionPerNode + 1;
    int remainingPartitions=partitionCount - avgPartitionPerNode * nodeSize;
    clusterPartitionRegistry.clearAll();
    for (    PartitionInfo partition : state) {
      Address owner=null;
      if ((owner=partition.getReplicaAddress(index)) != null) {
        clusterPartitionRegistry.add(owner,partition.getPartitionId());
      }
 else {
        partitionsToArrange.add(partition.getPartitionId());
      }
    }
    for (    Address address : clusterPartitionRegistry.getAddresses()) {
      int size=clusterPartitionRegistry.size(address);
      if (size == maxPartitionPerNode) {
        if (remainingPartitions > 0 && --remainingPartitions == 0) {
          maxPartitionPerNode=avgPartitionPerNode;
        }
        continue;
      }
      int diff=(size - maxPartitionPerNode);
      for (int i=0; i < diff; i++) {
        int remove=rand.nextInt(clusterPartitionRegistry.size(address));
        Integer partitionId=clusterPartitionRegistry.remove(address,remove);
        partitionsToArrange.add(partitionId);
      }
    }
    Collections.shuffle(partitionsToArrange);
    for (    Address address : clusterPartitionRegistry.getAddresses()) {
      final int queueSize=partitionsToArrange.size();
      int count=0;
      while (clusterPartitionRegistry.size(address) < maxPartitionPerNode && count < queueSize) {
        Integer partitionId=partitionsToArrange.poll();
        count++;
        if (clusterPartitionRegistry.contains(address,partitionId)) {
          partitionsToArrange.offer(partitionId);
        }
 else {
          clusterPartitionRegistry.add(address,partitionId);
          PartitionInfo p=state[partitionId];
          p.setReplicaAddress(index,address);
        }
      }
      if (remainingPartitions > 0 && --remainingPartitions == 0) {
        maxPartitionPerNode=avgPartitionPerNode;
      }
    }
    final int maxTries=partitionsToArrange.size() * nodeSize;
    int tries=0;
    while (tries++ < maxTries && !partitionsToArrange.isEmpty()) {
      Integer partitionId=partitionsToArrange.poll();
      MemberImpl member=members.get(rand.nextInt(members.size()));
      Address address=member.getAddress();
      if (!clusterPartitionRegistry.contains(address,partitionId)) {
        clusterPartitionRegistry.add(address,partitionId);
        PartitionInfo p=state[partitionId];
        p.setReplicaAddress(index,address);
      }
 else {
        partitionsToArrange.offer(partitionId);
      }
    }
  }
}
