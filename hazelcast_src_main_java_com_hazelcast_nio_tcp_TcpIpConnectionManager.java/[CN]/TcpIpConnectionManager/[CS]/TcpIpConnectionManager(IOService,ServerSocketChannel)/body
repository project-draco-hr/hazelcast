{
  this.ioService=ioService;
  this.serverSocketChannel=serverSocketChannel;
  this.logger=ioService.getLogger(TcpIpConnectionManager.class.getName());
  this.socketReceiveBufferSize=ioService.getSocketReceiveBufferSize() * IOService.KILO_BYTE;
  this.socketSendBufferSize=ioService.getSocketSendBufferSize() * IOService.KILO_BYTE;
  this.socketLingerSeconds=ioService.getSocketLingerSeconds();
  this.socketKeepAlive=ioService.getSocketKeepAlive();
  this.socketNoDelay=ioService.getSocketNoDelay();
  this.selectorThreadCount=ioService.getSelectorThreadCount();
  this.inSelectors=new InSelectorImpl[selectorThreadCount];
  this.outSelectors=new OutSelectorImpl[selectorThreadCount];
  final Collection<Integer> ports=ioService.getOutboundPorts();
  this.outboundPortCount=ports == null ? 0 : ports.size();
  if (ports != null) {
    outboundPorts.addAll(ports);
  }
  this.socketChannelWrapperFactory=ioService.getSocketChannelWrapperFactory();
  this.portableContext=ioService.getPortableContext();
  this.selectorImbalancWorkaroundEnabled=parseBoolean(System.getProperty("hazelcast.selectorhack.enabled","false"));
  if (selectorImbalancWorkaroundEnabled) {
    selectorIndexPerHostMap=new ConcurrentHashMap<String,Integer>();
    logger.severe("WARNING!!!! The 'hazelcast.selectorhack.enabled' has been enabled. This feature should not be used " + "in a production environment. It is a temporary work around to deal with imbalances between selector-load. " + "This issue will be fixed at some point in time. Using this feature in a production environment can lead "+ "to other imbalance problems, e.g. when multiple members are on the same machine. Also this feature is not "+ "100% reliable.  ");
  }
 else {
    selectorIndexPerHostMap=null;
  }
}
