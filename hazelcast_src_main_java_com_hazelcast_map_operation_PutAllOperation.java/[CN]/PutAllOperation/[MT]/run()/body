{
  backupRecordInfos=new ArrayList<RecordInfo>();
  backupEntrySet=new ArrayList<Map.Entry<Data,Data>>();
  int partitionId=getPartitionId();
  RecordStore recordStore=mapService.getRecordStore(partitionId,name);
  Set<Map.Entry<Data,Data>> entries=entrySet.getEntrySet();
  InternalPartitionService partitionService=getNodeEngine().getPartitionService();
  Set<Data> keysToInvalidate=new HashSet<Data>();
  for (  Map.Entry<Data,Data> entry : entries) {
    Data dataKey=entry.getKey();
    Data dataValue=entry.getValue();
    if (partitionId == partitionService.getPartitionId(dataKey)) {
      Data dataOldValue=null;
      if (initialLoad) {
        recordStore.putFromLoad(dataKey,dataValue,-1);
      }
 else {
        dataOldValue=mapService.toData(recordStore.put(dataKey,dataValue,-1));
      }
      mapService.interceptAfterPut(name,dataValue);
      EntryEventType eventType=dataOldValue == null ? EntryEventType.ADDED : EntryEventType.UPDATED;
      mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,dataOldValue,dataValue);
      keysToInvalidate.add(dataKey);
      if (mapContainer.getWanReplicationPublisher() != null && mapContainer.getWanMergePolicy() != null) {
        Record record=recordStore.getRecord(dataKey);
        final SimpleEntryView entryView=mapService.createSimpleEntryView(dataKey,mapService.toData(dataValue),record);
        mapService.publishWanReplicationUpdate(name,entryView);
      }
      backupEntrySet.add(entry);
      RecordInfo replicationInfo=mapService.createRecordInfo(recordStore.getRecord(dataKey));
      backupRecordInfos.add(replicationInfo);
    }
  }
  invalidateNearCaches(keysToInvalidate);
}
