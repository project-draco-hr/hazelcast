{
  backupRecordInfos=new ArrayList<RecordInfo>();
  backupEntrySet=new ArrayList<Map.Entry<Data,Data>>();
  int partitionId=getPartitionId();
  RecordStore recordStore=mapService.getMapServiceContext().getRecordStore(partitionId,name);
  Set<Map.Entry<Data,Data>> entries=entrySet.getEntrySet();
  InternalPartitionService partitionService=getNodeEngine().getPartitionService();
  Set<Data> keysToInvalidate=new HashSet<Data>();
  for (  Map.Entry<Data,Data> entry : entries) {
    Data dataKey=entry.getKey();
    Data dataValue=entry.getValue();
    if (partitionId == partitionService.getPartitionId(dataKey)) {
      Data dataOldValue=null;
      if (initialLoad) {
        recordStore.putFromLoad(dataKey,dataValue,-1);
      }
 else {
        dataOldValue=mapService.getMapServiceContext().toData(recordStore.put(dataKey,dataValue,-1));
      }
      mapService.getMapServiceContext().interceptAfterPut(name,dataValue);
      EntryEventType eventType=dataOldValue == null ? EntryEventType.ADDED : EntryEventType.UPDATED;
      mapService.getMapServiceContext().getMapEventPublisher().publishEvent(getCallerAddress(),name,eventType,dataKey,dataOldValue,dataValue);
      keysToInvalidate.add(dataKey);
      if (mapContainer.getWanReplicationPublisher() != null && mapContainer.getWanMergePolicy() != null) {
        Record record=recordStore.getRecord(dataKey);
        final EntryView entryView=EntryViews.createSimpleEntryView(dataKey,mapService.getMapServiceContext().toData(dataValue),record);
        mapService.getMapServiceContext().getMapEventPublisher().publishWanReplicationUpdate(name,entryView);
      }
      backupEntrySet.add(entry);
      RecordInfo replicationInfo=Records.buildRecordInfo(recordStore.getRecord(dataKey));
      backupRecordInfos.add(replicationInfo);
    }
  }
  invalidateNearCaches(keysToInvalidate);
}
