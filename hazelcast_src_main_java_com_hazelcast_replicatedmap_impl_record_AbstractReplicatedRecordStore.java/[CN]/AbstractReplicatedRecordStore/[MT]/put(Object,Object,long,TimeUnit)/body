{
  isNotNull(key,"key");
  isNotNull(value,"value");
  isNotNull(timeUnit,"timeUnit");
  if (ttl < 0) {
    throw new IllegalArgumentException("ttl must be a positive integer");
  }
  long time=Clock.currentTimeMillis();
  storage.checkState();
  V oldValue=null;
  K marshalledKey=(K)marshallKey(key);
  V marshalledValue=(V)marshallValue(value);
synchronized (getMutex(marshalledKey)) {
    final long ttlMillis=ttl == 0 ? 0 : timeUnit.toMillis(ttl);
    final ReplicatedRecord old=storage.get(marshalledKey);
    ReplicatedRecord<K,V> record=old;
    if (old == null) {
      record=buildReplicatedRecord(marshalledKey,marshalledValue,new VectorClockTimestamp(),ttlMillis);
      storage.put(marshalledKey,record);
    }
 else {
      oldValue=(V)old.getValueInternal();
      storage.get(marshalledKey).setValue(marshalledValue,localMemberHash,ttlMillis);
    }
    if (ttlMillis > 0) {
      scheduleTtlEntry(ttlMillis,marshalledKey,marshalledValue);
    }
 else {
      cancelTtlEntry(marshalledKey);
    }
    VectorClockTimestamp vectorClockTimestamp=record.incrementVectorClock(localMember);
    ReplicationMessage message=buildReplicationMessage(key,value,vectorClockTimestamp,ttlMillis);
    replicationPublisher.publishReplicatedMessage(message);
  }
  Object unmarshalledOldValue=unmarshallValue(oldValue);
  fireEntryListenerEvent(key,unmarshalledOldValue,value);
  if (replicatedMapConfig.isStatisticsEnabled()) {
    mapStats.incrementPuts(Clock.currentTimeMillis() - time);
  }
  return unmarshalledOldValue;
}
