{
  Node node=((FactoryImpl)hazelcast).node;
  PartitionManager pm=node.concurrentMapManager.getPartitionManager();
  DataInputStream dis=null;
  try {
    ByteArrayInputStream bais=new ByteArrayInputStream(bytesRecordSet);
    boolean compressed=bais.read() != 0;
    if (compressed) {
      dis=new DataInputStream(new InflaterInputStream(bais));
    }
 else {
      dis=new DataInputStream(bais);
    }
    int size=dis.readInt();
    RecordSet recordSet=new RecordSet();
    for (int i=0; i < size; i++) {
      DataRecordEntry r=new DataRecordEntry();
      r.readData(dis);
      recordSet.addDataRecordEntry(r);
    }
    if (recordCount != recordSet.getRecords().size()) {
      getLogger().log(Level.SEVERE,"Migration record count mismatch! => " + "expected-count: " + size + ", actual-count: "+ recordSet.getRecords().size()+ "\nfrom: "+ from+ ", partition: "+ partitionId+ ", replica: "+ replicaIndex);
    }
    pm.doMigrate(partitionId,replicaIndex,recordSet,from);
    return Boolean.TRUE;
  }
 catch (  Throwable e) {
    Level level=Level.WARNING;
    if (e instanceof IllegalStateException) {
      level=Level.FINEST;
    }
    getLogger().log(level,e.getMessage(),e);
  }
 finally {
    IOUtil.closeResource(dis);
  }
  return Boolean.FALSE;
}
