{
  if (state == ACTIVE) {
    throw new IllegalStateException("Transaction is already active");
  }
  checkThread();
  if (threadFlag.get() != null) {
    throw new IllegalStateException("Nested transactions are not allowed!");
  }
  setThreadFlag(Boolean.TRUE);
  startTime=Clock.currentTimeMillis();
  backupAddresses=transactionManagerService.pickBackupAddresses(durability);
  if (durability > 0 && backupAddresses != null && transactionType == TransactionType.TWO_PHASE) {
    final OperationService operationService=nodeEngine.getOperationService();
    List<Future> futures=new ArrayList<Future>(backupAddresses.length);
    for (    Address backupAddress : backupAddresses) {
      if (nodeEngine.getClusterService().getMember(backupAddress) != null) {
        final Invocation inv=operationService.createInvocationBuilder(TransactionManagerServiceImpl.SERVICE_NAME,new BeginTxBackupOperation(txOwnerUuid,txnId,xid),backupAddress).build();
        futures.add(inv.invoke());
      }
    }
    for (    Future future : futures) {
      try {
        future.get(timeoutMillis,TimeUnit.MILLISECONDS);
      }
 catch (      MemberLeftException e) {
        nodeEngine.getLogger(Transaction.class).warning("Member left while replicating tx begin: " + e);
      }
catch (      Throwable e) {
        if (e instanceof ExecutionException) {
          e=e.getCause() != null ? e.getCause() : e;
        }
        if (e instanceof TargetNotMemberException) {
          nodeEngine.getLogger(Transaction.class).warning("Member left while replicating tx begin: " + e);
        }
 else {
          throw ExceptionUtil.rethrow(e);
        }
      }
    }
  }
  state=ACTIVE;
}
