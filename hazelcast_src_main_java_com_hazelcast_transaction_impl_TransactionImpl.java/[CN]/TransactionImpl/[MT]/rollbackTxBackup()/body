{
  final OperationService operationService=nodeEngine.getOperationService();
  final List<Future> futures=new ArrayList<Future>(transactionLog.size());
  if (durability > 0 && transactionType.equals(TransactionType.TWO_PHASE)) {
    for (    Address backupAddress : backupAddresses) {
      if (nodeEngine.getClusterService().getMember(backupAddress) != null) {
        final Future f=operationService.invokeOnTarget(TransactionManagerServiceImpl.SERVICE_NAME,new RollbackTxBackupOperation(txnId),backupAddress);
        futures.add(f);
      }
    }
    waitWithDeadline(futures,timeoutMillis,TimeUnit.MILLISECONDS,rollbackTxExceptionHandler);
    futures.clear();
  }
}
