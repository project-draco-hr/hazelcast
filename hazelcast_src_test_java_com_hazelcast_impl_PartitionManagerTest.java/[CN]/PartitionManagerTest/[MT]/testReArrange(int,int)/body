{
  LinkedList<MemberImpl> members=new LinkedList<MemberImpl>();
  List<Address> listOfAddresses=new ArrayList<Address>();
  for (int i=0; i < NODE_COUNT; i++) {
    Address address=new Address("localhost",5701 + i);
    listOfAddresses.add(address);
    members.add(new MemberImpl(address,true));
  }
  Address thisAddress=new Address("localhost",5701);
  ConcurrentMapManager concurrentMapManager=mock(ConcurrentMapManager.class);
  Node node=mock(Node.class);
  when(node.getLogger(PartitionManager.class.getName())).thenReturn(new NoLogFactory().getLogger("test"));
  when(concurrentMapManager.getNode()).thenReturn(node);
  when(concurrentMapManager.getPartitionCount()).thenReturn(BLOCK_COUNT);
  when(concurrentMapManager.getBlocks()).thenReturn(createBlocks(BLOCK_COUNT,thisAddress));
  when(concurrentMapManager.getThisAddress()).thenReturn(thisAddress);
  when(concurrentMapManager.getMembers()).thenReturn(members);
  when(concurrentMapManager.isMaster()).thenReturn(true);
  PartitionManager partitionManager=new PartitionManager(concurrentMapManager);
  partitionManager.reArrangeBlocks();
  assertEquals(BLOCK_COUNT * (NODE_COUNT - 1) / NODE_COUNT,partitionManager.lsBlocksToMigrate.size());
  Block[] blocks=concurrentMapManager.getBlocks();
  for (  Block block : blocks) {
    assertEquals(thisAddress,block.getOwner());
  }
  for (  Block block : partitionManager.lsBlocksToMigrate) {
    assertTrue(listOfAddresses.contains(block.getMigrationAddress()));
  }
}
