{
  int nodeCount=0;
  final IMap[] maps=new IMap[instances.length];
  for (int i=0; i < 20; i++) {
    for (int j=0; j < instances.length; j++) {
      final HazelcastInstance hz=instances[j];
      if (hz != null) {
        if (i == 0) {
          maps[j]=hz.getMap(MAP_NAME);
          nodeCount++;
        }
        assertEquals(expectedSize,maps[j].size());
      }
    }
    Thread.sleep(10);
  }
  final int expectedBackupSize=Math.min(nodeCount - 1,backupCount) * expectedSize;
  for (int i=0; i < 100; i++) {
    long ownedSize=getTotalOwnedEntryCount(maps);
    long backupSize=getTotalBackupEntryCount(maps);
    if (ownedSize == expectedSize && backupSize == expectedBackupSize) {
      int votes=0;
      for (      HazelcastInstance hz : instances) {
        if (hz != null) {
          votes+=TestUtil.getNode(hz).getPartitionService().hasOnGoingMigration() ? 0 : 1;
        }
      }
      if (votes == nodeCount) {
        break;
      }
    }
    Thread.sleep(250);
  }
  long backupSize=getTotalBackupEntryCount(maps);
  assertEquals("Backup size invalid, node-count: " + nodeCount,expectedBackupSize,backupSize);
}
