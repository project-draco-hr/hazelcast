{
  int nodeCount=0;
  final IMap[] maps=new IMap[instances.length];
  for (int i=0; i < 20; i++) {
    for (int j=0; j < instances.length; j++) {
      final HazelcastInstance hz=instances[j];
      if (hz != null) {
        if (i == 0) {
          maps[j]=hz.getMap(MAP_NAME);
          nodeCount++;
        }
        assertEquals(expectedSize,maps[j].size());
      }
    }
    Thread.sleep(10);
  }
  final int expectedBackupSize=Math.min(nodeCount - 1,backupCount) * expectedSize;
  for (int i=0; i < 600; i++) {
    long ownedSize=getTotalOwnedEntryCount(maps);
    long backupSize=getTotalBackupEntryCount(maps);
    if (ownedSize == expectedSize && backupSize == expectedBackupSize) {
      int votes=0;
      for (      HazelcastInstance hz : instances) {
        if (hz != null) {
          votes+=TestUtil.getNode(hz).getPartitionService().hasOnGoingMigration() ? 0 : 1;
        }
      }
      if (votes == nodeCount) {
        break;
      }
    }
    Thread.sleep(1000);
  }
  long actualBackupSize=getTotalBackupEntryCount(maps);
  if (expectedBackupSize > actualBackupSize) {
    fail("Missing backups, node-count: " + nodeCount + ", expected:<"+ expectedBackupSize+ "> but was:<"+ actualBackupSize+ ">");
  }
}
