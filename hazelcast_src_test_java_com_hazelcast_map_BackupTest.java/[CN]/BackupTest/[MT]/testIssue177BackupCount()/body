{
  final TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(10);
  final Config config=getConfig();
  config.getMapConfig(MAP_NAME).setBackupCount(1).setStatisticsEnabled(true);
  final Random rand=new Random();
  final AtomicReferenceArray<HazelcastInstance> instances=new AtomicReferenceArray<HazelcastInstance>(10);
  final int count=10000;
  final int totalCount=count * (instances.length() - 1);
  final CountDownLatch latch=new CountDownLatch(instances.length());
  for (int i=0; i < instances.length(); i++) {
    final int finalI=i;
    Thread thread=new Thread(){
      public void run(){
        try {
          Thread.sleep(3000 * finalI);
          HazelcastInstance instance=nodeFactory.newHazelcastInstance(config);
          instances.set(finalI,instance);
          Thread.sleep(rand.nextInt(100));
          if (finalI != 0) {
            for (int j=0; j < 10000; j++) {
              instance.getMap(MAP_NAME).put(getName() + "-" + j,"value");
            }
          }
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
 finally {
          latch.countDown();
        }
      }
    }
;
    thread.start();
  }
  assertTrue(latch.await(5,TimeUnit.MINUTES));
  final int trials=50;
  for (int i=0; i < trials; i++) {
    long totalOwned=0L;
    long totalBackup=0L;
    for (int j=0; j < instances.length(); j++) {
      HazelcastInstance hz=instances.get(j);
      LocalMapStats stats=hz.getMap(MAP_NAME).getLocalMapStats();
      totalOwned+=stats.getOwnedEntryCount();
      totalBackup+=stats.getBackupEntryCount();
    }
    assertEquals("Owned entry count is wrong! ",totalCount,totalOwned);
    if (i < trials - 1) {
      if (totalBackup == totalCount) {
        break;
      }
      Thread.sleep(1000);
    }
 else {
      assertEquals("Backup entry count is wrong! ",totalCount,totalBackup);
    }
  }
}
