{
  this.nodeEngine=nodeEngine;
  final Node node=nodeEngine.getNode();
  logger=node.getLogger(ExecutionService.class.getName());
  final ClassLoader classLoader=node.getConfig().getClassLoader();
  final ExecutorThreadFactory threadFactory=new PoolExecutorThreadFactory(node.threadGroup,node.getThreadPoolNamePrefix("cached"),classLoader);
  cachedExecutorService=new ThreadPoolExecutor(5,Integer.MAX_VALUE,60L,TimeUnit.SECONDS,new SynchronousQueue<Runnable>(),threadFactory,new RejectedExecutionHandler(){
    public void rejectedExecution(    Runnable r,    ThreadPoolExecutor executor){
      logger.log(Level.FINEST,"Node is shutting down; discarding the task: " + r);
    }
  }
);
  final String scheduledThreadName=node.getThreadNamePrefix("scheduled");
  scheduledExecutorService=Executors.newSingleThreadScheduledExecutor(new ExecutorThreadFactory(node.threadGroup,classLoader){
    protected String newThreadName(){
      return scheduledThreadName;
    }
  }
);
  enableRemoveOnCancelIfAvailable();
  final int coreSize=Runtime.getRuntime().availableProcessors();
  register(SYSTEM_EXECUTOR,coreSize * 5,Integer.MAX_VALUE);
  register(ASYNC_EXECUTOR,coreSize * 10,coreSize * 100000);
  scheduledManagedExecutor=register("hz:scheduled",coreSize * 10,coreSize * 100000);
}
