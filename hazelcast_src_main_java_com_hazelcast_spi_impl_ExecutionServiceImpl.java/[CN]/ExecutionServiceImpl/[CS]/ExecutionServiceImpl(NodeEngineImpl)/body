{
  this.nodeEngine=nodeEngine;
  final Node node=nodeEngine.getNode();
  logger=node.getLogger(ExecutionService.class.getName());
  final ClassLoader classLoader=node.getConfigClassLoader();
  final ThreadFactory threadFactory=new PoolExecutorThreadFactory(node.threadGroup,node.getThreadPoolNamePrefix("cached"),classLoader);
  cachedExecutorService=new ThreadPoolExecutor(CORE_POOL_SIZE,Integer.MAX_VALUE,KEEP_ALIVE_TIME,TimeUnit.SECONDS,new SynchronousQueue<Runnable>(),threadFactory,new RejectedExecutionHandler(){
    public void rejectedExecution(    Runnable r,    ThreadPoolExecutor executor){
      if (logger.isFinestEnabled()) {
        logger.finest("Node is shutting down; discarding the task: " + r);
      }
    }
  }
);
  final String scheduledThreadName=node.getThreadNamePrefix("scheduled");
  scheduledExecutorService=new ScheduledThreadPoolExecutor(1,new SingleExecutorThreadFactory(node.threadGroup,classLoader,scheduledThreadName));
  enableRemoveOnCancelIfAvailable();
  final int coreSize=Runtime.getRuntime().availableProcessors();
  register(SYSTEM_EXECUTOR,coreSize,Integer.MAX_VALUE,ExecutorType.CACHED);
  register(SCHEDULED_EXECUTOR,coreSize * POOL_MULTIPLIER,coreSize * QUEUE_MULTIPIER,ExecutorType.CACHED);
  defaultScheduledExecutorServiceDelegate=getScheduledExecutor(SCHEDULED_EXECUTOR);
  completableFutureTask=new CompletableFutureTask();
  scheduleWithFixedDelay(completableFutureTask,INITIAL_DELAY,PERIOD,TimeUnit.MILLISECONDS);
}
