{
  Map<Member,ArrayList<Integer>> memberPartitions=getMemberPartitions();
  List<Future> responses=new ArrayList<Future>(memberPartitions.size());
  Data data=toData(op);
  for (  Map.Entry<Member,ArrayList<Integer>> mp : memberPartitions.entrySet()) {
    Address target=((MemberImpl)mp.getKey()).getAddress();
    SingleTargetInvocation inv=new SingleTargetInvocation(this,serviceName,new PartitionIterator(mp.getValue(),data),target,100,500);
    inv.invoke();
    responses.add(inv);
  }
  Map<Integer,Object> partitionResults=new HashMap<Integer,Object>(PARTITION_COUNT);
  for (  Future r : responses) {
    Object result=r.get();
    Map<Integer,Object> partialResult=null;
    if (result instanceof Data) {
      partialResult=(Map<Integer,Object>)toObject((Data)r.get());
    }
 else {
      partialResult=(Map<Integer,Object>)result;
    }
    System.out.println(partialResult);
    partitionResults.putAll(partialResult);
  }
  List<Integer> failedPartitions=new ArrayList<Integer>(0);
  for (  Map.Entry<Integer,Object> partitionResult : partitionResults.entrySet()) {
    int partitionId=partitionResult.getKey();
    Object result=partitionResult.getValue();
    if (result instanceof Exception) {
      failedPartitions.add(partitionId);
    }
  }
  Thread.sleep(500);
  System.out.println("TRYING AGAIN...");
  for (  Integer failedPartition : failedPartitions) {
    Invocation inv=createSinglePartitionInvocation(serviceName,op,failedPartition).build();
    inv.invoke();
    partitionResults.put(failedPartition,inv);
  }
  for (  Integer failedPartition : failedPartitions) {
    Future f=(Future)partitionResults.get(failedPartition);
    Object result=f.get();
    System.out.println(failedPartition + " now response " + result);
    partitionResults.put(failedPartition,result);
  }
  return partitionResults;
}
