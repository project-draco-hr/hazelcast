{
  final int partitionId=packet.blockId;
  final boolean backup=packet.longValue == 1;
  final Data data=packet.getValueData();
  final long callId=packet.callId;
  final Address caller=packet.conn.getEndPoint();
  final String serviceName=packet.name;
  final Executor executor=getExecutor(partitionId,backup);
  executor.execute(new Runnable(){
    public void run(){
      try {
        Object response=null;
        final Operation op=(Operation)toObject(data);
        PartitionInfo partitionInfo=getPartitionInfo(partitionId);
        Address owner=partitionInfo.getOwner();
        if (partitionId != -1 && !(op instanceof NonBlockingOperation) && !getThisAddress().equals(owner)) {
          response=new Response(new WrongTargetException(getThisAddress(),owner),true);
        }
 else {
          try {
            setOperationContext(op,serviceName,caller,callId,partitionId);
            response=op.call();
          }
 catch (          Throwable e) {
            e.printStackTrace();
            response=e;
          }
        }
        if (!(op instanceof NoReply)) {
          if (!(response instanceof Operation)) {
            response=new Response(response);
          }
          packet.clearForResponse();
          packet.blockId=partitionId;
          packet.callId=callId;
          packet.longValue=(response instanceof NonBlockingOperation) ? 1 : 0;
          packet.setValue(toData(response));
          packet.name=serviceName;
          node.concurrentMapManager.sendOrReleasePacket(packet,packet.conn);
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
);
}
