{
  final long now=nowInNanos();
  final MapService mapService=this.mapService;
  final NodeEngine nodeEngine=mapService.getNodeEngine();
  final ClusterService clusterService=nodeEngine.getClusterService();
  final InternalPartitionService partitionService=nodeEngine.getPartitionService();
  final Address thisAddress=clusterService.getThisAddress();
  final int partitionCount=partitionService.getPartitionCount();
  Map<Integer,Integer> partitionToEntryCountHolder=Collections.emptyMap();
  List<DelayedEntry> sortedDelayedEntries=Collections.emptyList();
  boolean createLazy=true;
  for (int partitionId=0; partitionId < partitionCount; partitionId++) {
    final InternalPartition partition=partitionService.getPartition(partitionId);
    final Address owner=partition.getOwnerOrNull();
    if (owner == null) {
      continue;
    }
    final PartitionContainer partitionContainer=mapService.getPartitionContainer(partitionId);
    final RecordStore recordStore=partitionContainer.getExistingRecordStore(mapName);
    if (recordStore == null) {
      continue;
    }
    final WriteBehindQueue<DelayedEntry> queue=recordStore.getWriteBehindQueue();
    final List<DelayedEntry> delayedEntries=filterLessThanOrEqualToTime(queue,now,TimeUnit.NANOSECONDS);
    if (!owner.equals(thisAddress)) {
      if (now < lastRunTimeInNanos + backupRunIntervalTimeInNanos) {
        doInBackup(queue,delayedEntries,partitionId);
      }
      continue;
    }
    if (delayedEntries.size() == 0) {
      continue;
    }
    if (createLazy) {
      partitionToEntryCountHolder=new HashMap<Integer,Integer>();
      sortedDelayedEntries=new ArrayList<DelayedEntry>();
      createLazy=false;
    }
    partitionToEntryCountHolder.put(partitionId,delayedEntries.size());
    sortedDelayedEntries.addAll(delayedEntries);
  }
  if (sortedDelayedEntries.isEmpty()) {
    return;
  }
  lastRunTimeInNanos=nowInNanos();
  Collections.sort(sortedDelayedEntries,DELAYED_ENTRY_COMPARATOR);
  final Map<Integer,Collection<DelayedEntry>> failsPerPartition=new HashMap<Integer,Collection<DelayedEntry>>();
  mapStoreManager.process(sortedDelayedEntries,failsPerPartition);
  removeProcessedEntries(mapService,mapName,partitionToEntryCountHolder,failsPerPartition);
}
