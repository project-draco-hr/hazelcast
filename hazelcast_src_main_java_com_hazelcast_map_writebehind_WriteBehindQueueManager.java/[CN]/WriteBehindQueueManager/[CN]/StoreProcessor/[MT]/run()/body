{
  final MapService mapService=this.mapService;
  final long now=Clock.currentTimeMillis();
  final NodeEngine nodeEngine=mapService.getNodeEngine();
  final ClusterService clusterService=nodeEngine.getClusterService();
  final InternalPartitionService partitionService=nodeEngine.getPartitionService();
  final Address thisAddress=clusterService.getThisAddress();
  final int partitionCount=partitionService.getPartitionCount();
  Map<Integer,Integer> partitionToEntryCountHolder=Collections.emptyMap();
  List<DelayedEntry> sortedDelayedEntries=Collections.emptyList();
  boolean createLazy=true;
  for (int partitionId=0; partitionId < partitionCount; partitionId++) {
    final InternalPartition partition=partitionService.getPartition(partitionId);
    final Address owner=partition.getOwnerOrNull();
    RecordStore recordStore;
    if (owner == null || (recordStore=getRecordStoreOrNull(mapName,partitionId)) == null) {
      continue;
    }
    final WriteBehindQueue<DelayedEntry> queue=recordStore.getWriteBehindQueue();
    final List<DelayedEntry> delayedEntries=filterItemsLessThanOrEqualToTime(queue,now);
    if (delayedEntries.isEmpty()) {
      continue;
    }
    if (!owner.equals(thisAddress)) {
      if (now < lastRunTime + backupRunIntervalTime) {
        doInBackup(queue,delayedEntries,partitionId);
      }
      continue;
    }
    if (createLazy) {
      partitionToEntryCountHolder=new HashMap<Integer,Integer>();
      sortedDelayedEntries=new ArrayList<DelayedEntry>();
      createLazy=false;
    }
    partitionToEntryCountHolder.put(partitionId,delayedEntries.size());
    sortedDelayedEntries.addAll(delayedEntries);
  }
  if (sortedDelayedEntries.isEmpty()) {
    return;
  }
  lastRunTime=now;
  Collections.sort(sortedDelayedEntries,DELAYED_ENTRY_COMPARATOR);
  Map<Integer,Collection<DelayedEntry>> failsPerPartition=mapStoreManager.process(sortedDelayedEntries);
  removeProcessedEntries(mapName,partitionToEntryCountHolder);
  addFailsToQueue(mapName,failsPerPartition);
}
