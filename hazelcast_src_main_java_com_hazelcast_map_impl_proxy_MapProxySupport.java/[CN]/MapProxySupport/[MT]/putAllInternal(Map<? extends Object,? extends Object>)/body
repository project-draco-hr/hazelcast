{
  NodeEngine nodeEngine=getNodeEngine();
  InternalPartitionService partitionService=nodeEngine.getPartitionService();
  OperationService operationService=nodeEngine.getOperationService();
  int partitionCount=partitionService.getPartitionCount();
  final MapServiceContext mapServiceContext=getService().getMapServiceContext();
  try {
    List<Future> futures=new ArrayList<Future>(partitionCount);
    MapEntrySet[] entrySetPerPartition=new MapEntrySet[partitionCount];
    for (    Entry entry : entries.entrySet()) {
      checkNotNull(entry.getKey(),NULL_KEY_IS_NOT_ALLOWED);
      checkNotNull(entry.getValue(),NULL_VALUE_IS_NOT_ALLOWED);
      int partitionId=partitionService.getPartitionId(entry.getKey());
      MapEntrySet entrySet=entrySetPerPartition[partitionId];
      if (entrySet == null) {
        entrySet=new MapEntrySet();
        entrySetPerPartition[partitionId]=entrySet;
      }
      Data keyData=mapServiceContext.toData(entry.getKey(),partitionStrategy);
      Data valueData=mapServiceContext.toData(entry.getValue());
      entrySet.add(new AbstractMap.SimpleImmutableEntry<Data,Data>(keyData,valueData));
    }
    for (int partitionId=0; partitionId < entrySetPerPartition.length; partitionId++) {
      MapEntrySet entrySet=entrySetPerPartition[partitionId];
      if (entrySet != null) {
        Operation op=new PutAllOperation(name,entrySet).setPartitionId(partitionId);
        final long size=entrySet.getEntrySet().size();
        final long time=System.currentTimeMillis();
        InternalCompletableFuture<Object> f=operationService.invokeOnPartition(SERVICE_NAME,op,partitionId);
        f.andThen(new ExecutionCallback(){
          @Override public void onResponse(          Object response){
            LocalMapStatsProvider localMapStatsProvider=mapServiceContext.getLocalMapStatsProvider();
            LocalMapStatsImpl localMapStats=localMapStatsProvider.getLocalMapStatsImpl(name);
            long currentTime=System.currentTimeMillis();
            localMapStats.incrementPuts(size,currentTime - time);
          }
          @Override public void onFailure(          Throwable t){
          }
        }
);
        futures.add(f);
      }
    }
    for (    Future future : futures) {
      future.get();
    }
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
}
