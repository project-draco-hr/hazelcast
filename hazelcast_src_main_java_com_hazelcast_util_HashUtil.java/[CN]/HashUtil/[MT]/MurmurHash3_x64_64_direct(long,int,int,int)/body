{
  long h1=0x9368e53c2f6af274L ^ seed;
  long h2=0x586dcd208f7cd3fdL ^ seed;
  long c1=0x87c37b91114253d5L;
  long c2=0x4cf5ad432745937fL;
  long k1=0;
  long k2=0;
  for (int i=0; i < len / 16; i++) {
    k1=MurmurHash3_getBlock_direct(address,(i * 2 * 8) + offset);
    k2=MurmurHash3_getBlock_direct(address,((i * 2 + 1) * 8) + offset);
    k1*=c1;
    k1=(k1 << 23) | (k1 >>> 64 - 23);
    k1*=c2;
    h1^=k1;
    h1+=h2;
    h2=(h2 << 41) | (h2 >>> 64 - 41);
    k2*=c2;
    k2=(k2 << 23) | (k2 >>> 64 - 23);
    k2*=c1;
    h2^=k2;
    h2+=h1;
    h1=h1 * 3 + 0x52dce729;
    h2=h2 * 3 + 0x38495ab5;
    c1=c1 * 5 + 0x7b7d159c;
    c2=c2 * 5 + 0x6bce6396;
  }
  k1=0;
  k2=0;
  int tail=((len >>> 4) << 4) + offset;
switch (len & 15) {
case 15:
    k2^=(long)MEM.getByte(address + tail + 14) << 48;
case 14:
  k2^=(long)MEM.getByte(address + tail + 13) << 40;
case 13:
k2^=(long)MEM.getByte(address + tail + 12) << 32;
case 12:
k2^=(long)MEM.getByte(address + tail + 11) << 24;
case 11:
k2^=(long)MEM.getByte(address + tail + 10) << 16;
case 10:
k2^=(long)MEM.getByte(address + tail + 9) << 8;
case 9:
k2^=MEM.getByte(address + tail + 8);
case 8:
k1^=(long)MEM.getByte(address + tail + 7) << 56;
case 7:
k1^=(long)MEM.getByte(address + tail + 6) << 48;
case 6:
k1^=(long)MEM.getByte(address + tail + 5) << 40;
case 5:
k1^=(long)MEM.getByte(address + tail + 4) << 32;
case 4:
k1^=(long)MEM.getByte(address + tail + 3) << 24;
case 3:
k1^=(long)MEM.getByte(address + tail + 2) << 16;
case 2:
k1^=(long)MEM.getByte(address + tail + 1) << 8;
case 1:
k1^=MEM.getByte(address + tail);
k1*=c1;
k1=(k1 << 23) | (k1 >>> 64 - 23);
k1*=c2;
h1^=k1;
h1+=h2;
h2=(h2 << 41) | (h2 >>> 64 - 41);
k2*=c2;
k2=(k2 << 23) | (k2 >>> 64 - 23);
k2*=c1;
h2^=k2;
h2+=h1;
h1=h1 * 3 + 0x52dce729;
h2=h2 * 3 + 0x38495ab5;
default :
}
h2^=len;
h1+=h2;
h2+=h1;
h1=MurmurHash3_fmix(h1);
h2=MurmurHash3_fmix(h2);
h1+=h2;
return h1;
}
