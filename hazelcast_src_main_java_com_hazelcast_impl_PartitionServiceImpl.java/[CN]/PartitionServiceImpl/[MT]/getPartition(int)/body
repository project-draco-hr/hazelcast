{
  PartitionProxy partition=mapPartitions.get(partitionId);
  if (partition != null && partition.getOwner() != null)   return partition;
  final BlockingQueue<PartitionReal> responseQ=ResponseQueueFactory.newResponseQueue();
  concurrentMapManager.enqueueAndReturn(new Processable(){
    public void process(){
      Block block=concurrentMapManager.partitionManager.getOrCreateBlock(partitionId);
      MemberImpl memberOwner=null;
      MemberImpl memberMigration=null;
      if (block.getOwner() != null) {
        if (concurrentMapManager.thisAddress.equals(block.getOwner())) {
          memberOwner=concurrentMapManager.thisMember;
        }
 else {
          memberOwner=concurrentMapManager.getMember(block.getOwner());
        }
      }
      if (block.getMigrationAddress() != null) {
        if (concurrentMapManager.thisAddress.equals(block.getMigrationAddress())) {
          memberMigration=concurrentMapManager.thisMember;
        }
 else {
          memberMigration=concurrentMapManager.getMember(block.getMigrationAddress());
        }
      }
      responseQ.offer(new PartitionReal(partitionId,memberOwner,memberMigration));
    }
  }
);
  partition=new PartitionProxy(partitionId);
  try {
    PartitionReal partitionReal=responseQ.take();
    mapRealPartitions.put(partitionId,partitionReal);
    PartitionProxy oldPartitionProxy=mapPartitions.putIfAbsent(partitionId,partition);
    if (oldPartitionProxy != null) {
      return oldPartitionProxy;
    }
  }
 catch (  InterruptedException ignored) {
  }
  return partition;
}
