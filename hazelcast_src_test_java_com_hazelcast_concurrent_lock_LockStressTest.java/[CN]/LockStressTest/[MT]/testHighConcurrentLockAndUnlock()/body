{
  Config config=new Config();
  final TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(1);
  final HazelcastInstance hz=nodeFactory.newHazelcastInstance(config);
  final String key="key";
  final int threadCount=100;
  final int lockCountPerThread=5000;
  final int locks=50;
  final CountDownLatch latch=new CountDownLatch(threadCount);
  final AtomicInteger totalCount=new AtomicInteger();
class InnerTest implements Runnable {
    public void run(){
      boolean live=true;
      Random rand=new Random();
      try {
        for (int j=0; j < lockCountPerThread && live; j++) {
          final Lock lock=hz.getLock(key + rand.nextInt(locks));
          lock.lock();
          try {
            if (j % 100 == 0) {
              System.out.println(Thread.currentThread().getName() + " is at:" + j);
            }
            totalCount.incrementAndGet();
            Thread.sleep(1);
          }
 catch (          InterruptedException e) {
            e.printStackTrace();
            break;
          }
 finally {
            try {
              lock.unlock();
            }
 catch (            Exception e) {
              e.printStackTrace();
              live=false;
            }
          }
        }
      }
  finally {
        latch.countDown();
      }
    }
  }
  ExecutorService executorService=Executors.newCachedThreadPool();
  for (int i=0; i < threadCount; i++) {
    executorService.execute(new InnerTest());
  }
  try {
    assertTrue("Lock tasks stuck!",latch.await(2,TimeUnit.MINUTES));
    assertEquals((threadCount * lockCountPerThread),totalCount.get());
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
 finally {
    try {
      hz.getLifecycleService().terminate();
    }
 catch (    Throwable ignored) {
    }
    executorService.shutdownNow();
  }
}
