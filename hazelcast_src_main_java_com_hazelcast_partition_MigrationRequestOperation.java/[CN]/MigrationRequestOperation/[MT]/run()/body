{
  final NodeEngine nodeEngine=getNodeEngine();
  final Address masterAddress=nodeEngine.getMasterAddress();
  if (!masterAddress.equals(migrationInfo.getMaster())) {
    throw new RetryableHazelcastException("Migration initiator is not master node! => " + toString());
  }
  if (!masterAddress.equals(getCallerAddress())) {
    throw new RetryableHazelcastException("Caller is not master node! => " + toString());
  }
  final Address from=migrationInfo.getFromAddress();
  final Address to=migrationInfo.getToAddress();
  if (to.equals(from)) {
    getLogger().log(Level.WARNING,"To and from addresses are the same! => " + toString());
    success=false;
    return;
  }
  if (from == null) {
    getLogger().log(Level.FINEST,"From address is null => " + toString());
  }
  if (migrationInfo.startProcessing()) {
    try {
      final Member target=nodeEngine.getClusterService().getMember(to);
      if (target == null) {
        throw new RetryableHazelcastException("Destination of migration could not be found! => " + toString());
      }
      final PartitionServiceImpl partitionService=getService();
      partitionService.addActiveMigration(migrationInfo);
      final long timeout=nodeEngine.getGroupProperties().PARTITION_MIGRATION_TIMEOUT.getLong();
      final Collection<Operation> tasks=prepareMigrationTasks();
      if (tasks.size() > 0) {
        final SerializationService serializationService=nodeEngine.getSerializationService();
        final ObjectDataOutput out=serializationService.createObjectDataOutput(1024 * 32);
        try {
          out.writeInt(tasks.size());
          for (          Operation task : tasks) {
            serializationService.writeObject(out,task);
          }
          final byte[] data=IOUtil.compress(out.toByteArray());
          final MigrationOperation migrationOperation=new MigrationOperation(migrationInfo,data,tasks.size());
          Invocation inv=nodeEngine.getOperationService().createInvocationBuilder(PartitionServiceImpl.SERVICE_NAME,migrationOperation,to).setTryPauseMillis(1000).setReplicaIndex(getReplicaIndex()).build();
          Future future=inv.invoke();
          success=(Boolean)nodeEngine.toObject(future.get(timeout,TimeUnit.SECONDS));
        }
  finally {
          IOUtil.closeResource(out);
        }
      }
 else {
        success=true;
      }
    }
 catch (    Throwable e) {
      if (e instanceof ExecutionException) {
        e=e.getCause() != null ? e.getCause() : e;
      }
      Level level=(e instanceof MemberLeftException || e instanceof InterruptedException) || !getNodeEngine().isActive() ? Level.FINEST : Level.WARNING;
      getLogger().log(level,e.getMessage(),e);
      success=false;
    }
 finally {
      migrationInfo.doneProcessing();
    }
  }
 else {
    getLogger().log(Level.WARNING,"Migration is cancelled -> " + migrationInfo);
    success=false;
  }
}
