{
  final Address from=migrationInfo.getFromAddress();
  final Address to=migrationInfo.getToAddress();
  if (to.equals(from)) {
    getLogger().log(Level.FINEST,"To and from addresses are same! => " + toString());
    success=false;
    return;
  }
  if (from == null) {
    getLogger().log(Level.FINEST,"From address is null => " + toString());
  }
  final PartitionServiceImpl partitionService=getService();
  try {
    Member target=partitionService.getMember(to);
    if (target == null) {
      getLogger().log(Level.WARNING,"Target member of task could not be found! => " + toString());
      success=false;
      return;
    }
    partitionService.addActiveMigration(migrationInfo);
    final NodeEngine nodeEngine=getNodeEngine();
    final long timeout=nodeEngine.getGroupProperties().PARTITION_MIGRATION_TIMEOUT.getLong();
    final Collection<Operation> tasks=prepareMigrationTasks();
    if (tasks.size() > 0) {
      final SerializationService serializationService=nodeEngine.getSerializationService();
      final ObjectDataOutput out=serializationService.createObjectDataOutput(1024 * 32);
      try {
        out.writeInt(tasks.size());
        for (        Operation task : tasks) {
          serializationService.writeObject(out,task);
        }
        final byte[] data=IOUtil.compress(out.toByteArray());
        final MigrationOperation migrationOperation=new MigrationOperation(migrationInfo,data,tasks.size());
        Invocation inv=nodeEngine.getOperationService().createInvocationBuilder(PartitionServiceImpl.SERVICE_NAME,migrationOperation,to).setTryCount(3).setTryPauseMillis(1000).setReplicaIndex(getReplicaIndex()).build();
        Future future=inv.invoke();
        success=(Boolean)nodeEngine.toObject(future.get(timeout,TimeUnit.SECONDS));
      }
  finally {
        IOUtil.closeResource(out);
      }
    }
 else {
      success=true;
    }
  }
 catch (  Throwable e) {
    onError(e);
  }
}
