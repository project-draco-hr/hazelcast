{
  if (response != null && response != BasicInvocation.WAIT_RESPONSE) {
    return response;
  }
  long timeoutMs=getTimeoutMs(time,unit);
  long maxCallTimeoutMs=getMaxCallTimeoutMs();
  boolean longPolling=timeoutMs > maxCallTimeoutMs;
  int pollCount=0;
  while (timeoutMs >= 0) {
    long pollTimeoutMs=min(maxCallTimeoutMs,timeoutMs);
    long startMs=Clock.currentTimeMillis();
    long lastPollTime=0;
    pollCount++;
    try {
      pollResponse(pollTimeoutMs);
      lastPollTime=Clock.currentTimeMillis() - startMs;
      timeoutMs=decrementTimeout(timeoutMs,lastPollTime);
      if (response == BasicInvocation.WAIT_RESPONSE) {
        RESPONSE_FIELD_UPDATER.compareAndSet(this,BasicInvocation.WAIT_RESPONSE,null);
        continue;
      }
 else       if (response != null) {
        if (response != BasicInvocation.INTERRUPTED_RESPONSE && interrupted) {
          Thread.currentThread().interrupt();
        }
        return response;
      }
    }
 catch (    InterruptedException e) {
      interrupted=true;
    }
    if (!interrupted && longPolling) {
      Address target=basicInvocation.getTarget();
      if (basicInvocation.remote && basicInvocation.nodeEngine.getThisAddress().equals(target)) {
        continue;
      }
      basicInvocation.logger.warning("No response for " + lastPollTime + " ms. "+ toString());
      boolean executing=isOperationExecuting(target);
      if (!executing) {
        Object operationTimeoutException=newOperationTimeoutException(pollCount,pollTimeoutMs);
        set(operationTimeoutException);
      }
    }
  }
  return BasicInvocation.TIMEOUT_RESPONSE;
}
