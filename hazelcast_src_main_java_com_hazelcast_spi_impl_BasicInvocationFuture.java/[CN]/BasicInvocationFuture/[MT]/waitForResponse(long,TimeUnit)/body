{
  if (responseAvailable(response)) {
    return response;
  }
  waiterCount.incrementAndGet();
  try {
    long timeoutMs=toTimeoutMs(time,unit);
    long maxCallTimeoutMs=getMaxCallTimeout();
    boolean longPolling=timeoutMs > maxCallTimeoutMs;
    int pollCount=0;
    while (timeoutMs >= 0) {
      long pollTimeoutMs=min(maxCallTimeoutMs,timeoutMs);
      long startMs=Clock.currentTimeMillis();
      long lastPollTime=0;
      pollCount++;
      try {
        pollResponse(pollTimeoutMs);
        lastPollTime=Clock.currentTimeMillis() - startMs;
        timeoutMs=decrementTimeout(timeoutMs,lastPollTime);
        if (response == BasicInvocation.WAIT_RESPONSE) {
          RESPONSE_FIELD_UPDATER.compareAndSet(this,BasicInvocation.WAIT_RESPONSE,null);
          continue;
        }
 else         if (response != null) {
          if (response != BasicInvocation.INTERRUPTED_RESPONSE && interrupted) {
            Thread.currentThread().interrupt();
          }
          return response;
        }
      }
 catch (      InterruptedException e) {
        interrupted=true;
      }
      if (!interrupted && longPolling) {
        Address target=invocation.getTarget();
        if (invocation.remote && invocation.nodeEngine.getThisAddress().equals(target)) {
          continue;
        }
        invocation.logger.warning("No response for " + lastPollTime + " ms. "+ toString());
        boolean executing=isOperationExecuting(target);
        if (!executing) {
          Object operationTimeoutException=newOperationTimeoutException(pollCount * pollTimeoutMs);
          set(operationTimeoutException);
        }
      }
    }
    return BasicInvocation.TIMEOUT_RESPONSE;
  }
  finally {
    waiterCount.decrementAndGet();
  }
}
