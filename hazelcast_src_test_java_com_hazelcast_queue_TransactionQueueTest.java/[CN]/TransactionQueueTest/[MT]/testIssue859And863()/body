{
  final int numberOfMessages=20000;
  final AtomicInteger count=new AtomicInteger();
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(2);
  Config config=new Config();
  HazelcastInstance instance1=factory.newHazelcastInstance(config);
  HazelcastInstance instance2=factory.newHazelcastInstance(config);
  String inQueueName="in@foo";
  String outQueueName="out@foo";
  for (int i=0; i < numberOfMessages; i++) {
    if (!instance1.getQueue(inQueueName).offer(new byte[1024])) {
      throw new RuntimeException("initial put did not work");
    }
  }
class MoveMessage extends Thread {
    private final HazelcastInstance hazelcastInstance;
    private final String inQueueName;
    private final String outQueueName;
    private volatile boolean active=true;
    public MoveMessage(    HazelcastInstance hazelcastInstance,    String inQueueName,    String outQueueName){
      this.hazelcastInstance=hazelcastInstance;
      this.inQueueName=inQueueName;
      this.outQueueName=outQueueName;
    }
    public void run(){
      while (active && count.get() != numberOfMessages) {
        TransactionContext transactionContext=hazelcastInstance.newTransactionContext();
        transactionContext.beginTransaction();
        try {
          TransactionalQueue<Object> queue=transactionContext.getQueue(inQueueName);
          Object value=queue.poll();
          if (value != null) {
            TransactionalQueue<Object> outQueue=transactionContext.getQueue(outQueueName);
            if (!outQueue.offer(value)) {
              throw new RuntimeException();
            }
          }
          transactionContext.commitTransaction();
          if (value != null) {
            count.incrementAndGet();
          }
        }
 catch (        Exception e) {
          transactionContext.rollbackTransaction();
        }
      }
    }
  }
  MoveMessage moveMessage1=new MoveMessage(instance1,inQueueName,outQueueName);
  MoveMessage moveMessage2=new MoveMessage(instance2,inQueueName,outQueueName);
  moveMessage1.start();
  moveMessage2.start();
  while (count.get() < numberOfMessages / 2) {
    Thread.sleep(10);
  }
  moveMessage2.active=false;
  instance2.getLifecycleService().terminate();
  moveMessage2.join(10000);
  moveMessage1.join(20000);
  try {
    assertEquals(numberOfMessages,instance1.getQueue(outQueueName).size());
    assertTrue(instance1.getQueue(inQueueName).isEmpty());
  }
  finally {
    moveMessage1.active=false;
  }
}
