{
  HazelcastInstanceProxy proxy=(HazelcastInstanceProxy)createHazelcastInstance();
  Field originalField=HazelcastInstanceProxy.class.getDeclaredField("original");
  originalField.setAccessible(true);
  HazelcastInstanceImpl hz=(HazelcastInstanceImpl)originalField.get(proxy);
  NodeEngine nodeEngine=hz.node.nodeEngine;
  ExecutionService es=nodeEngine.getExecutionService();
  final CountDownLatch latch1=new CountDownLatch(1);
  final CountDownLatch latch2=new CountDownLatch(2);
  Future future=es.submit("default",new Callable<String>(){
    @Override public String call(){
      try {
        return "success";
      }
  finally {
        latch1.countDown();
      }
    }
  }
);
  assertOpenEventually(latch1);
  final AtomicReference reference1=new AtomicReference();
  final AtomicReference reference2=new AtomicReference();
  final ICompletableFuture completableFuture=es.asCompletableFuture(future);
  completableFuture.andThen(new ExecutionCallback(){
    @Override public void onResponse(    Object response){
      reference1.set(response);
      latch2.countDown();
    }
    @Override public void onFailure(    Throwable t){
      reference1.set(t);
      latch2.countDown();
    }
  }
);
  completableFuture.andThen(new ExecutionCallback(){
    @Override public void onResponse(    Object response){
      reference2.set(response);
      latch2.countDown();
    }
    @Override public void onFailure(    Throwable t){
      reference2.set(t);
      latch2.countDown();
    }
  }
);
  assertOpenEventually(latch2);
  assertEquals("success",reference1.get());
  assertEquals("success",reference2.get());
}
