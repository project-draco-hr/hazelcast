{
  try {
    node.getFailedConnections().clear();
    final Collection<Address> colPossibleAddresses=getPossibleAddresses();
    colPossibleAddresses.remove(node.getThisAddress());
    for (    final Address possibleAddress : colPossibleAddresses) {
      logger.info("Connecting to possible member: " + possibleAddress);
      node.connectionManager.getOrConnect(possibleAddress);
    }
    boolean foundConnection=false;
    int numberOfSeconds=0;
    final int connectionTimeoutSeconds=getConnTimeoutSeconds();
    while (!foundConnection && numberOfSeconds < connectionTimeoutSeconds) {
      logger.finest("Removing failedConnections: " + node.getFailedConnections());
      colPossibleAddresses.removeAll(node.getFailedConnections());
      if (colPossibleAddresses.size() == 0) {
        break;
      }
      logger.finest("We are going to try to connect to each address" + colPossibleAddresses);
      for (      Address possibleAddress : colPossibleAddresses) {
        final Connection conn=node.connectionManager.getOrConnect(possibleAddress);
        if (conn != null) {
          foundConnection=true;
          logger.finest("Found a connection and sending join request to " + possibleAddress);
          node.clusterService.sendJoinRequest(possibleAddress,true);
        }
      }
      if (!foundConnection) {
        Thread.sleep(1000L);
        numberOfSeconds++;
      }
    }
    logger.finest("FOUND " + foundConnection);
    if (!foundConnection) {
      logger.finest("This node will assume master role since no possible member where connected to.");
      node.setAsMaster();
    }
 else {
      if (!node.joined()) {
        final int totalSleep=connectionTimeoutSeconds - numberOfSeconds;
        for (int i=0; i < totalSleep * 2 && !node.joined(); i++) {
          logger.finest("Waiting for join request answer, sleeping for 500 ms...");
          Thread.sleep(500L);
          Address masterAddress=node.getMasterAddress();
          if (masterAddress != null) {
            logger.finest("Sending join request to " + masterAddress);
            node.clusterService.sendJoinRequest(masterAddress,true);
          }
        }
        colPossibleAddresses.removeAll(node.getFailedConnections());
        if (colPossibleAddresses.size() == 0) {
          logger.finest("This node will assume master role since none of the possible members accepted join request.");
          node.setAsMaster();
        }
 else         if (!node.joined()) {
          boolean masterCandidate=true;
          for (          Address address : colPossibleAddresses) {
            if (node.connectionManager.getConnection(address) != null) {
              if (node.getThisAddress().hashCode() > address.hashCode()) {
                masterCandidate=false;
              }
            }
          }
          if (masterCandidate) {
            claimingMaster=true;
            Collection<Future<Boolean>> responses=new LinkedList<Future<Boolean>>();
            for (            Address address : colPossibleAddresses) {
              if (node.getConnectionManager().getConnection(address) != null) {
                logger.finest("Claiming myself as master node!");
                Invocation inv=node.nodeEngine.getOperationService().createInvocationBuilder(ClusterServiceImpl.SERVICE_NAME,new MasterClaim(),address).setTryCount(1).build();
                responses.add(inv.invoke());
              }
            }
            final long maxWait=TimeUnit.SECONDS.toMillis(10);
            long waitTime=0L;
            boolean allApprovedAsMaster=true;
            for (            Future<Boolean> response : responses) {
              if (!allApprovedAsMaster || waitTime > maxWait) {
                allApprovedAsMaster=false;
                break;
              }
              long t=Clock.currentTimeMillis();
              try {
                allApprovedAsMaster&=response.get(1,TimeUnit.SECONDS);
              }
 catch (              Exception e) {
                logger.finest(e);
                allApprovedAsMaster=false;
              }
 finally {
                waitTime+=(Clock.currentTimeMillis() - t);
              }
            }
            if (allApprovedAsMaster) {
              logger.finest(node.getThisAddress() + " Setting myself as master! group " + node.getConfig().getGroupConfig().getName()+ " possible addresses "+ colPossibleAddresses.size()+ " "+ colPossibleAddresses);
              node.setAsMaster();
              return;
            }
 else {
              lookForMaster(colPossibleAddresses);
            }
          }
 else {
            lookForMaster(colPossibleAddresses);
          }
        }
      }
    }
    colPossibleAddresses.clear();
    node.getFailedConnections().clear();
  }
 catch (  Throwable t) {
    logger.severe(t);
  }
}
