{
  int correlationId=clientMessage.getCorrelationId();
  final ClientInvocation future=deRegisterCallId(correlationId);
  if (future == null) {
    logger.warning("No call for callId: " + correlationId + ", response: "+ clientMessage);
    return;
  }
  if (ClientMessageType.EXCEPTION.id() == clientMessage.getMessageType()) {
    ExceptionResultParameters exceptionResultParameters=ExceptionResultParameters.decode(clientMessage);
    Throwable exception;
    boolean hasCause=!exceptionResultParameters.causeClassName.equals("null");
    if (hasCause) {
      Class<?> causeClazz=Class.forName(exceptionResultParameters.causeClassName);
      Constructor<?> causeConstructor=causeClazz.getDeclaredConstructor(new Class[]{String.class});
      causeConstructor.setAccessible(true);
      Throwable cause=(Throwable)causeConstructor.newInstance(exceptionResultParameters.message);
      Class<?> clazz=Class.forName(exceptionResultParameters.className);
      Constructor<?> constructor=clazz.getDeclaredConstructor(new Class[]{String.class,Throwable.class});
      constructor.setAccessible(true);
      exception=(Throwable)constructor.newInstance(exceptionResultParameters.message,cause);
    }
 else {
      Class<?> clazz=Class.forName(exceptionResultParameters.className);
      Constructor<?> constructor=clazz.getDeclaredConstructor(new Class[]{String.class});
      constructor.setAccessible(true);
      exception=(Throwable)constructor.newInstance(exceptionResultParameters.message);
    }
    future.notifyException(exception);
  }
 else {
    future.notify(clientMessage);
  }
}
