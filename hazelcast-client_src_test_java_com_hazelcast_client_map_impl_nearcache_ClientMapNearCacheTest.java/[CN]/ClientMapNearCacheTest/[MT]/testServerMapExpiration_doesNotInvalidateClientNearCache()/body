{
  String mapName=randomMapName();
  HazelcastInstance server=hazelcastFactory.newHazelcastInstance(newConfig());
  NearCacheConfig nearCacheConfig=newLongMaxIdleNearCacheConfig();
  ClientConfig clientConfig=newClientConfig();
  clientConfig.addNearCacheConfig(nearCacheConfig);
  HazelcastInstance client=hazelcastFactory.newHazelcastClient(clientConfig);
  IMap<Integer,Integer> serverMap=server.getMap(mapName);
  IMap<Integer,Integer> clientMap=client.getMap(mapName);
  final CountDownLatch expiredEventLatch=new CountDownLatch(2);
  EntryExpiredListener listener=new EntryExpiredListener(){
    @Override public void entryExpired(    EntryEvent event){
      expiredEventLatch.countDown();
    }
  }
;
  serverMap.addEntryListener(listener,false);
  clientMap.addEntryListener(listener,false);
  final CountDownLatch eventAddedLatch=new CountDownLatch(1);
  addNearCacheInvalidateListener(clientMap,eventAddedLatch);
  serverMap.put(1,23,6,TimeUnit.SECONDS);
  assertNotNull("The TTL value should still be available in the server map right after it was put there",serverMap.get(1));
  assertOpenEventually(eventAddedLatch);
  assertThatOwnedEntryCountEquals(clientMap,0);
  assertNotNull("The TTL value should still be available after the invalidation event arrived",clientMap.get(1));
  assertThatOwnedEntryCountEquals(clientMap,1);
  assertOpenEventually(expiredEventLatch);
  assertNull("The TTL value should be gone in the server map after its expiration",serverMap.get(1));
  assertNotNull("The TTL value should still be available in the near cache after server side expiration",clientMap.get(1));
  assertThatOwnedEntryCountEquals(clientMap,1);
}
