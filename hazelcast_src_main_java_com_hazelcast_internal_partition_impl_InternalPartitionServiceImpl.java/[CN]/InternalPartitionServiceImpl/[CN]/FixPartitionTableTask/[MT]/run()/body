{
  Collection<MemberImpl> members=node.clusterService.getMemberImpls();
  Collection<Future<PartitionRuntimeState>> futures=new ArrayList<Future<PartitionRuntimeState>>(members.size());
  for (  MemberImpl m : members) {
    if (m.localMember()) {
      continue;
    }
    Future<PartitionRuntimeState> future=nodeEngine.getOperationService().createInvocationBuilder(SERVICE_NAME,new FetchPartitionStateOperation(),m.getAddress()).setTryCount(Integer.MAX_VALUE).setCallTimeout(Long.MAX_VALUE).invoke();
    futures.add(future);
  }
  int version=stateVersion.get();
  PartitionRuntimeState newState=null;
  Collection<MigrationInfo> activeMigrations=new ArrayList<MigrationInfo>();
  Collection<MigrationInfo> allCompletedMigrations=new HashSet<MigrationInfo>();
  for (  Future<PartitionRuntimeState> future : futures) {
    try {
      PartitionRuntimeState state=future.get();
      if (version < state.getVersion()) {
        newState=state;
        version=state.getVersion();
      }
      allCompletedMigrations.addAll(state.getCompletedMigrations());
      if (state.getActiveMigration() != null) {
        activeMigrations.add(state.getActiveMigration());
      }
    }
 catch (    MemberLeftException e) {
    }
catch (    InterruptedException e) {
      e.printStackTrace();
    }
catch (    ExecutionException e) {
      e.printStackTrace();
    }
  }
  if (newState != null) {
    applyNewState(newState,thisAddress);
  }
  lock.lock();
  try {
    allCompletedMigrations.addAll(completedMigrations);
    completedMigrations.clear();
    completedMigrations.addAll(allCompletedMigrations);
  }
  finally {
    lock.unlock();
  }
}
