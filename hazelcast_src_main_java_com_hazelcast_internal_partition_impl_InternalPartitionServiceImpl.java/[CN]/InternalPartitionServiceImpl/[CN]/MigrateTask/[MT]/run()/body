{
  if (!node.isMaster()) {
    return;
  }
  final MigrationRequestOperation migrationRequestOp=new MigrationRequestOperation(migrationInfo);
  try {
    MigrationInfo info=migrationInfo;
    InternalPartitionImpl partition=partitions[info.getPartitionId()];
    Address owner=partition.getOwnerOrNull();
    if (owner == null) {
      logger.severe("ERROR: partition owner is not set! -> partitionId=" + info.getPartitionId() + " , "+ partition+ " -VS- "+ info);
      return;
    }
    if (!owner.equals(info.getSource())) {
      logger.severe("ERROR: partition owner is not the source of migration! -> partitionId=" + info.getPartitionId() + " , "+ partition+ " -VS- "+ info+ " found owner="+ owner);
      return;
    }
    internalMigrationListener.onMigrationStart(MigrationParticipant.MASTER,migrationInfo);
    sendMigrationEvent(migrationInfo,MigrationStatus.STARTED);
    Boolean result;
    MemberImpl fromMember=getMember(migrationInfo.getSource());
    if (logger.isFinestEnabled()) {
      logger.finest("Starting Migration: " + migrationInfo);
    }
    if (fromMember == null) {
      logger.warning("Partition is lost! Assign new owner and exit... partitionId=" + info.getPartitionId());
      result=Boolean.TRUE;
    }
 else {
      result=executeMigrateOperation(migrationRequestOp,fromMember);
    }
    processMigrationResult(result);
  }
 catch (  Throwable t) {
    final Level level=migrationInfo.isValid() ? Level.WARNING : Level.FINEST;
    logger.log(level,"Error [" + t.getClass() + ": "+ t.getMessage()+ "] while executing "+ migrationRequestOp);
    logger.finest(t);
    migrationOperationFailed();
  }
}
