{
  logger.info("Removing " + member);
  partitionStateManager.updateMemberGroupsSize();
  final Address deadAddress=member.getAddress();
  final Address thisAddress=node.getThisAddress();
  lock.lock();
  try {
    final int partitionStateVersionBeforeMemberRemove=partitionStateManager.getVersion();
    if (node.isMaster() && partitionStateManager.isInitialized() && node.getClusterService().getClusterState() == ClusterState.ACTIVE) {
      partitionStateManager.incrementVersion();
    }
    migrationManager.onMemberRemove(member);
    boolean isThisNodeNewMaster=node.isMaster() && !thisAddress.equals(lastMaster);
    if (isThisNodeNewMaster) {
      migrationManager.schedule(new FetchMostRecentPartitionTableTask(partitionStateVersionBeforeMemberRemove));
    }
    lastMaster=node.getMasterAddress();
    migrationManager.pauseMigration();
    replicaManager.cancelReplicaSyncRequestsTo(deadAddress);
    if (node.isMaster()) {
      migrationManager.schedule(new RepairPartitionTableTask(deadAddress));
    }
    if (!isThisNodeNewMaster) {
      migrationManager.resumeMigrationEventually();
    }
  }
  finally {
    lock.unlock();
  }
}
