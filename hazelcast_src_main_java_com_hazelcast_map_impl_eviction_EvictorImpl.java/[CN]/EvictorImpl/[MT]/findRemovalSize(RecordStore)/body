{
  MapConfig mapConfig=recordStore.getMapContainer().getMapConfig();
  int maxSize=mapConfig.getMaxSizeConfig().getSize();
  int currentRecordStoreSize=recordStore.size();
  MaxSizeConfig.MaxSizePolicy maxSizePolicy=mapConfig.getMaxSizeConfig().getMaxSizePolicy();
  int evictionPercentage=mapConfig.getEvictionPercentage();
switch (maxSizePolicy) {
case PER_PARTITION:
    double maxExpectedRecordStoreSize=Double.valueOf(maxSize * ((ONE_HUNDRED_PERCENT - evictionPercentage) / (1D * ONE_HUNDRED_PERCENT))).intValue();
  double diffFromTargetSize=currentRecordStoreSize - maxExpectedRecordStoreSize;
int prunedSize=currentRecordStoreSize * evictionPercentage / ONE_HUNDRED_PERCENT + 1;
return Math.max((int)diffFromTargetSize,prunedSize);
case PER_NODE:
maxExpectedRecordStoreSize=((EvictionCheckerImpl)evictionChecker).calculatePerNodeMaxRecordStoreSize(recordStore);
int expectedSizeAfterEviction=(int)(maxExpectedRecordStoreSize * (ONE_HUNDRED_PERCENT - evictionPercentage) / ONE_HUNDRED_PERCENT);
expectedSizeAfterEviction=Math.max(expectedSizeAfterEviction,1);
return currentRecordStoreSize - expectedSizeAfterEviction;
case USED_HEAP_PERCENTAGE:
case USED_HEAP_SIZE:
case FREE_HEAP_PERCENTAGE:
case FREE_HEAP_SIZE:
return Math.max(currentRecordStoreSize * evictionPercentage / ONE_HUNDRED_PERCENT,1);
default :
throw new IllegalArgumentException("Max size policy is not defined [" + maxSizePolicy + "]");
}
}
