{
  final ConcurrentReferenceHashMap<Data,Data> cache=new ConcurrentReferenceHashMap<Data,Data>(100,0.91f,40,ConcurrentReferenceHashMap.ReferenceType.STRONG,ConcurrentReferenceHashMap.ReferenceType.STRONG,null);
  for (int i=0; i < threadCount; i++) {
    es.execute(new Runnable(){
      public void run(){
        try {
          while (true) {
            int keyValue=(int)(random.nextFloat() * entryCount);
            Data key=ss.toData(keyValue);
            int operation=((int)(random.nextFloat() * 100));
            if (operation < getPercentage) {
              final Data data=cache.get(key);
              ss.toObject(data);
              stats.gets.incrementAndGet();
            }
 else             if (operation < getPercentage + putPercentage) {
              final Data oldData=cache.put(key,createValue());
              final Object o=ss.toObject(oldData);
              stats.puts.incrementAndGet();
            }
 else {
              final Data remove=cache.remove(key);
              final Object o=ss.toObject(remove);
              stats.removes.incrementAndGet();
            }
          }
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
      }
    }
);
  }
}
