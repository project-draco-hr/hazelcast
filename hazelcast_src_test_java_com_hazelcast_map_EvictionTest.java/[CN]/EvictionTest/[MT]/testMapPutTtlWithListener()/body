{
  Config cfg=new Config();
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(2);
  final HazelcastInstance[] instances=factory.newInstances(cfg);
  warmUpPartitions(instances);
  final int k=10;
  final int putCount=10000;
  final CountDownLatch latch=new CountDownLatch(k * putCount);
  final IMap map=instances[0].getMap("testMapEvictionTtlWithListener");
  final ExecutorService ex=Executors.newFixedThreadPool(k * 2);
  final AtomicBoolean error=new AtomicBoolean(false);
  final Set<Long> times=Collections.newSetFromMap(new ConcurrentHashMap<Long,Boolean>());
  map.addEntryListener(new EntryAdapter(){
    public void entryEvicted(    final EntryEvent event){
      ex.execute(new Runnable(){
        public void run(){
          final Long expectedEvictionTime=(Long)(event.getOldValue());
          long timeDifference=System.currentTimeMillis() - expectedEvictionTime;
          if (timeDifference > 5000) {
            error.set(true);
            times.add(timeDifference);
          }
          latch.countDown();
        }
      }
);
    }
  }
,true);
  for (int i=0; i < k; i++) {
    final int threadId=i;
    ex.execute(new Runnable(){
      public void run(){
        int ttl=(int)(Math.random() * 5000 + 3000);
        for (int j=0; j < putCount; j++) {
          final long expectedEvictionTime=ttl + System.currentTimeMillis();
          map.put(j + putCount * threadId,expectedEvictionTime,ttl,TimeUnit.MILLISECONDS);
        }
      }
    }
);
  }
  try {
    assertTrue(latch.await(1,TimeUnit.MINUTES));
    assertFalse("Some evictions took more than 3 seconds! -> " + times,error.get());
  }
  finally {
    ex.shutdownNow();
  }
}
