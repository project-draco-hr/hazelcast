{
  this.PARTITION_COUNT=concurrentMapManager.getPartitionCount();
  this.concurrentMapManager=concurrentMapManager;
  this.logger=concurrentMapManager.node.getLogger(PartitionManager.class.getName());
  this.partitions=new PartitionInfo[PARTITION_COUNT];
  for (int i=0; i < PARTITION_COUNT; i++) {
    this.partitions[i]=new PartitionInfo(i,new PartitionListener(){
      public void replicaChanged(      PartitionReplicaChangeEvent event){
        for (        PartitionListener partitionListener : lsPartitionListeners) {
          partitionListener.replicaChanged(event);
        }
        if (!concurrentMapManager.isMaster())         return;
        version.incrementAndGet();
      }
    }
);
  }
  final Node node=concurrentMapManager.node;
  partitionMigrationInterval=node.groupProperties.PARTITION_MIGRATION_INTERVAL.getInteger() * 1000;
  immediateBackupInterval=node.groupProperties.IMMEDIATE_BACKUP_INTERVAL.getInteger() * 1000;
  migrationService=new MigrationService(concurrentMapManager.node);
  migrationService.start();
  node.executorManager.getScheduledExecutorService().scheduleAtFixedRate(new Runnable(){
    public void run(){
      if (concurrentMapManager.isMaster()) {
        concurrentMapManager.enqueueAndReturn(new Processable(){
          public void process(){
            if (!node.isActive())             return;
            sendClusterRuntimeState();
          }
        }
);
      }
 else {
        final MigratingPartition currentMigratingPartition=migratingPartition;
        if (currentMigratingPartition != null) {
          try {
            AsyncRemotelyBooleanCallable rrp=node.clusterManager.new AsyncRemotelyBooleanCallable();
            rrp.executeProcess(node.getMasterAddress(),new CheckMigratingPartition(currentMigratingPartition));
            boolean valid=rrp.getResultAsBoolean(1);
            if (!valid) {
              logger.log(Level.INFO,currentMigratingPartition + " could not be validated with master! " + "Removing current MigratingPartition...");
              concurrentMapManager.enqueueAndReturn(new Processable(){
                public void process(){
                  migratingPartition=null;
                }
              }
);
            }
          }
 catch (          Throwable t) {
            logger.log(Level.WARNING,t.getMessage(),t);
          }
        }
      }
    }
  }
,5,5,TimeUnit.SECONDS);
}
