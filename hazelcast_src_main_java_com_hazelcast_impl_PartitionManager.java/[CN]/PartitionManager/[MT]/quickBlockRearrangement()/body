{
  if (!concurrentMapManager.isMaster())   return;
  createAllBlocks();
  Map<Address,Integer> addressBlocks=getCurrentMemberBlocks();
  if (addressBlocks.size() == 0) {
    return;
  }
  List<Block> ownableBlocks=new ArrayList<Block>();
  for (  Block blockReal : blocks) {
    if (blockReal.getOwner() == null) {
      ownableBlocks.add(blockReal);
    }
 else     if (!blockReal.isMigrating() && thisAddress.equals(blockReal.getOwner())) {
      if (isBlockEmpty(blockReal.getBlockId())) {
        ownableBlocks.add(blockReal);
      }
    }
    Integer countInt=addressBlocks.get(blockReal.getOwner());
    int count=(countInt == null) ? 0 : countInt;
    addressBlocks.put(blockReal.getOwner(),++count);
  }
  int aveBlockOwnCount=PARTITION_COUNT / (addressBlocks.size());
  Set<Address> allAddress=addressBlocks.keySet();
  for (  Address address : allAddress) {
    Integer countInt=addressBlocks.get(address);
    int count=(countInt == null) ? 0 : countInt;
    while (count < aveBlockOwnCount && ownableBlocks.size() > 0) {
      Block ownableBlock=ownableBlocks.remove(0);
      ownableBlock.setOwner(address);
      count++;
    }
  }
  sendBlocks(null);
}
