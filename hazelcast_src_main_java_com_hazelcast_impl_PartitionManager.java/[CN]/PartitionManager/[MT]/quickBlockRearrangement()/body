{
  if (!concurrentMapManager.isMaster())   return;
  createAllBlocks();
  Map<Address,Integer> addressBlockCounts=getCurrentMemberBlocks();
  if (addressBlockCounts.size() == 0) {
    return;
  }
  List<Block> lsEmptyBlocks=new ArrayList<Block>();
  for (  Block blockReal : blocks) {
    if (!blockReal.isMigrating() && thisAddress.equals(blockReal.getOwner())) {
      if (isBlockEmpty(blockReal.getBlockId())) {
        lsEmptyBlocks.add(blockReal);
      }
    }
    int count=addressBlockCounts.get(blockReal.getOwner());
    addressBlockCounts.put(blockReal.getOwner(),++count);
  }
  int aveBlockOwnCount=PARTITION_COUNT / (addressBlockCounts.size());
  for (  Address address : addressBlockCounts.keySet()) {
    int count=addressBlockCounts.get(address);
    while (count < aveBlockOwnCount && lsEmptyBlocks.size() > 0) {
      Block ownableBlock=lsEmptyBlocks.remove(0);
      ownableBlock.setOwner(address);
      count++;
    }
  }
  if (lsEmptyBlocks.size() > 0) {
    for (    Address address : addressBlockCounts.keySet()) {
      if (lsEmptyBlocks.size() == 0) {
        break;
      }
      Block ownableBlock=lsEmptyBlocks.remove(0);
      ownableBlock.setOwner(address);
    }
  }
  sendBlocks(null);
}
