{
  if (!concurrentMapManager.isMaster())   return;
  createAllBlocks();
  Map<Address,List<Block>> addressBlocks=getCurrentMemberBlocks();
  if (addressBlocks.size() == 0) {
    return;
  }
  List<Block> lsEmptyBlocks=new ArrayList<Block>();
  for (  Block blockReal : blocks) {
    if (!blockReal.isMigrating() && thisAddress.equals(blockReal.getOwner())) {
      if (isBlockEmpty(blockReal.getBlockId())) {
        lsEmptyBlocks.add(blockReal);
      }
    }
  }
  int aveBlockOwnCount=PARTITION_COUNT / (addressBlocks.size());
  for (  Address address : addressBlocks.keySet()) {
    List<Block> blocks=addressBlocks.get(address);
    int diff=(aveBlockOwnCount - blocks.size());
    for (int i=0; i < diff && lsEmptyBlocks.size() > 0; i++) {
      Block block=lsEmptyBlocks.remove(0);
      block.setOwner(address);
    }
  }
  if (lsEmptyBlocks.size() > 0) {
    for (    Address address : addressBlocks.keySet()) {
      if (lsEmptyBlocks.size() == 0) {
        break;
      }
      Block ownableBlock=lsEmptyBlocks.remove(0);
      ownableBlock.setOwner(address);
    }
  }
  sendBlocks(null);
  partitionServiceImpl.reset();
}
