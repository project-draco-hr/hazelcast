{
  Block blockReal=blocks[blockInfo.getBlockId()];
  if (!thisAddress.equals(blockInfo.getOwner())) {
    throw new RuntimeException(thisAddress + ". migrateBlock should be called from owner: " + blockInfo);
  }
  if (!blockInfo.isMigrating()) {
    throw new RuntimeException(thisAddress + ". migrateBlock cannot have non-migrating block: " + blockInfo);
  }
  if (blockInfo.getOwner().equals(blockInfo.getMigrationAddress())) {
    throw new RuntimeException(thisAddress + ". migrateBlock cannot have same owner and migrationAddress:" + blockInfo);
  }
  if (!node.isActive() || node.factory.restarted) {
    return null;
  }
  if (concurrentMapManager.isSuperClient()) {
    return null;
  }
  if (blockReal.isMigrationStarted())   return null;
  blockReal.setMigrationStarted(true);
  blockReal.setOwner(blockInfo.getOwner());
  blockReal.setMigrationAddress(blockInfo.getMigrationAddress());
  logger.log(Level.FINEST,"migrate blockInfo " + blockInfo);
  List<Record> lsRecordsToMigrate=new ArrayList<Record>(1000);
  Collection<CMap> cmaps=concurrentMapManager.maps.values();
  for (  final CMap cmap : cmaps) {
    for (    Record rec : cmap.mapRecords.values()) {
      if (rec.isActive() && concurrentMapManager.isOwned(rec)) {
        if (rec.getKeyData() == null || rec.getKeyData().size() == 0) {
          throw new RuntimeException("Record.key is null or empty " + rec.getKeyData());
        }
        if (rec.getBlockId() == blockInfo.getBlockId()) {
          cmap.onMigrate(rec);
          Record recordCopy=rec.copy();
          lsRecordsToMigrate.add(recordCopy);
          cmap.markAsEvicted(rec);
        }
      }
    }
  }
  return lsRecordsToMigrate;
}
