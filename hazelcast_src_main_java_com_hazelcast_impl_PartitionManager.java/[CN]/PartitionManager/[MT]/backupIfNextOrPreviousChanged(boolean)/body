{
  boolean shouldBackup=false;
  if (add && node.clusterManager.isNextChanged()) {
    shouldBackup=true;
  }
 else   if (!add && node.clusterManager.isPreviousChanged()) {
    shouldBackup=true;
  }
  if (shouldBackup) {
    List<Record> lsOwnedRecords=new ArrayList<Record>(1000);
    Collection<CMap> cmaps=concurrentMapManager.maps.values();
    for (    final CMap cmap : cmaps) {
      for (      Record rec : cmap.mapRecords.values()) {
        if (rec.isActive()) {
          if (rec.getKey() == null || rec.getKey().size() == 0) {
            throw new RuntimeException("Record.key is null or empty " + rec.getKey());
          }
          lsOwnedRecords.add(rec);
        }
      }
    }
    for (    final Record rec : lsOwnedRecords) {
      parallelExecutorBackups.execute(new FallThroughRunnable(){
        public void doRun(){
          concurrentMapManager.backupRecord(rec);
        }
      }
);
    }
  }
}
