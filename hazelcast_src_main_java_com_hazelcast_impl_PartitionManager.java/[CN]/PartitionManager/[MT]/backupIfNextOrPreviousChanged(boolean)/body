{
  boolean shouldBackup=node.clusterManager.isNextChanged();
  if (shouldBackup) {
    List<Record> lsOwnedRecords=new ArrayList<Record>(1000);
    Collection<CMap> cmaps=concurrentMapManager.maps.values();
    for (    final CMap cmap : cmaps) {
      for (      Record rec : cmap.mapRecords.values()) {
        if (rec.isActive()) {
          if (rec.getKey() == null || rec.getKey().size() == 0) {
            throw new RuntimeException("Record.key is null or empty " + rec.getKey());
          }
          lsOwnedRecords.add(rec);
        }
      }
    }
    if (!add)     logger.log(Level.INFO,thisAddress + " will backup " + lsOwnedRecords.size());
    for (    final Record rec : lsOwnedRecords) {
      parallelExecutorBackups.execute(new FallThroughRunnable(){
        public void doRun(){
          concurrentMapManager.backupRecord(rec);
        }
      }
);
    }
  }
}
