{
  List<Record> lsOwnedRecords=new ArrayList<Record>(1000);
  Collection<CMap> cmaps=concurrentMapManager.maps.values();
  for (  final CMap cmap : cmaps) {
    boolean shouldBackup=false;
    if (cmap.backupCount > 0) {
      if (add) {
        shouldBackup=node.clusterManager.isNextChanged(cmap.backupCount);
      }
 else {
        shouldBackup=node.clusterManager.isNextChanged(cmap.backupCount) || node.clusterManager.isPreviousChanged(cmap.backupCount);
      }
    }
    if (shouldBackup) {
      for (      Record rec : cmap.mapRecords.values()) {
        if (rec.isActive()) {
          if (rec.getKeyData() == null || rec.getKeyData().size() == 0) {
            throw new RuntimeException("Record.key is null or empty " + rec.getKeyData());
          }
          lsOwnedRecords.add(rec);
        }
      }
    }
  }
  if (!add)   logger.log(Level.FINEST,thisAddress + " will backup " + lsOwnedRecords.size());
  backupTaskCount.addAndGet(lsOwnedRecords.size());
  for (  final Record rec : lsOwnedRecords) {
    parallelExecutorBackups.execute(new FallThroughRunnable(){
      public void doRun(){
        try {
          concurrentMapManager.backupRecord(rec);
        }
  finally {
          backupTaskCount.decrementAndGet();
        }
      }
    }
);
  }
}
