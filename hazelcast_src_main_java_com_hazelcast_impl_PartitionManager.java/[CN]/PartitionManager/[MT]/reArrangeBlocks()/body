{
  if (concurrentMapManager.isMaster()) {
    Map<Address,Integer> addressBlocks=getCurrentMemberBlocks();
    if (addressBlocks.size() == 0) {
      return;
    }
    List<Block> lsBlocksToRedistribute=new ArrayList<Block>();
    int aveBlockOwnCount=PARTITION_COUNT / (addressBlocks.size());
    for (    Block blockReal : blocks) {
      if (!blockReal.isMigrating()) {
        Integer countInt=addressBlocks.get(blockReal.getOwner());
        int count=(countInt == null) ? 0 : countInt;
        if (count >= aveBlockOwnCount) {
          lsBlocksToRedistribute.add(new Block(blockReal));
        }
 else {
          addressBlocks.put(blockReal.getOwner(),++count);
        }
      }
    }
    lsBlocksToMigrate.clear();
    for (    Address address : addressBlocks.keySet()) {
      Integer countInt=addressBlocks.get(address);
      int count=(countInt == null) ? 0 : countInt;
      while (count < aveBlockOwnCount && lsBlocksToRedistribute.size() > 0) {
        Block blockToMigrate=lsBlocksToRedistribute.remove(0);
        addBlockToMigrate(blockToMigrate,address);
        count++;
      }
    }
    lsBlocksToRedistribute.removeAll(lsBlocksToMigrate);
    for (    MemberImpl member : concurrentMapManager.getMembers()) {
      if (lsBlocksToRedistribute.size() == 0) {
        break;
      }
      Block blockToMigrate=lsBlocksToRedistribute.remove(0);
      addBlockToMigrate(blockToMigrate,member.getAddress());
    }
    Collections.shuffle(lsBlocksToMigrate);
  }
}
