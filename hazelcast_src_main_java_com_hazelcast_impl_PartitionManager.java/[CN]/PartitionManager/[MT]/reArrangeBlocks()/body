{
  if (concurrentMapManager.isMaster()) {
    Map<Address,List<Block>> addressBlocks=getCurrentMemberBlocks();
    if (addressBlocks.size() == 0) {
      return;
    }
    List<Block> lsBlocksToRedistribute=new ArrayList<Block>();
    int aveBlockOwnCount=PARTITION_COUNT / (addressBlocks.size());
    int membersWithMorePartitionsThanAverage=PARTITION_COUNT - addressBlocks.keySet().size() * aveBlockOwnCount;
    for (    Address address : addressBlocks.keySet()) {
      List<Block> blocks=addressBlocks.get(address);
      if (membersWithMorePartitionsThanAverage != 0 && blocks.size() == aveBlockOwnCount + 1) {
        membersWithMorePartitionsThanAverage--;
        continue;
      }
      int diff=(blocks.size() - aveBlockOwnCount);
      for (int i=0; i < diff; i++) {
        Block block=blocks.remove(0);
        lsBlocksToRedistribute.add(block);
      }
    }
    lsBlocksToMigrate.clear();
    for (    Address address : addressBlocks.keySet()) {
      List<Block> blocks=addressBlocks.get(address);
      int count=blocks.size();
      while (count < aveBlockOwnCount && lsBlocksToRedistribute.size() > 0) {
        Block blockToMigrate=lsBlocksToRedistribute.remove(0);
        addBlockToMigrate(blockToMigrate,address);
        count++;
      }
    }
    lsBlocksToRedistribute.removeAll(lsBlocksToMigrate);
    for (    Address address : addressBlocks.keySet()) {
      if (lsBlocksToRedistribute.size() == 0) {
        break;
      }
      if (addressBlocks.get(address).size() != aveBlockOwnCount + 1) {
        Block blockToMigrate=lsBlocksToRedistribute.remove(0);
        addBlockToMigrate(blockToMigrate,address);
      }
    }
    Collections.shuffle(lsBlocksToMigrate);
  }
}
