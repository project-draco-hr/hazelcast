{
  if (concurrentMapManager.isMaster()) {
    Map<Address,Integer> addressBlockCounts=getCurrentMemberBlocks();
    if (addressBlockCounts.size() == 0) {
      return;
    }
    List<Block> lsBlocksToRedistribute=new ArrayList<Block>();
    int aveBlockOwnCount=PARTITION_COUNT / (addressBlockCounts.size());
    for (    Block blockReal : blocks) {
      if (!blockReal.isMigrating()) {
        int count=addressBlockCounts.get(blockReal.getOwner());
        if (count >= aveBlockOwnCount) {
          lsBlocksToRedistribute.add(new Block(blockReal));
        }
 else {
          addressBlockCounts.put(blockReal.getOwner(),++count);
        }
      }
    }
    lsBlocksToMigrate.clear();
    for (    Address address : addressBlockCounts.keySet()) {
      int count=addressBlockCounts.get(address);
      while (count < aveBlockOwnCount && lsBlocksToRedistribute.size() > 0) {
        Block blockToMigrate=lsBlocksToRedistribute.remove(0);
        addBlockToMigrate(blockToMigrate,address);
        count++;
      }
    }
    lsBlocksToRedistribute.removeAll(lsBlocksToMigrate);
    for (    Address address : addressBlockCounts.keySet()) {
      if (lsBlocksToRedistribute.size() == 0) {
        break;
      }
      Block blockToMigrate=lsBlocksToRedistribute.remove(0);
      addBlockToMigrate(blockToMigrate,address);
    }
    Collections.shuffle(lsBlocksToMigrate);
  }
}
