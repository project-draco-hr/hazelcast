{
  Address deadAddress=deadMember.getAddress();
  Address thisAddress=concurrentMapManager.getThisAddress();
  if (deadAddress == null || deadAddress.equals(thisAddress)) {
    return;
  }
  if (!hasStorageMember()) {
    reset();
  }
  final boolean migrationStatus=migrationActive.getAndSet(false);
  concurrentMapManager.partitionServiceImpl.reset();
  checkMigratingPartitionForDead(deadAddress);
  int[] indexesOfDead=new int[partitions.length];
  for (  PartitionInfo partition : partitions) {
    indexesOfDead[partition.getPartitionId()]=partition.getReplicaIndexOf(deadAddress);
  }
  if (!deadMember.isLiteMember()) {
    clearTaskQueues();
    for (    PartitionInfo partition : partitions) {
      while (partition.onDeadAddress(deadAddress))       ;
    }
  }
  fixCMapsForDead(deadAddress,indexesOfDead);
  fixReplicasAndPartitionsForDead(deadMember,indexesOfDead);
  final Node node=concurrentMapManager.node;
  final long waitBeforeMigrationActivate=node.groupProperties.CONNECTION_MONITOR_INTERVAL.getLong() * node.groupProperties.CONNECTION_MONITOR_MAX_FAULTS.getInteger() * 10;
  node.executorManager.getScheduledExecutorService().schedule(new Runnable(){
    public void run(){
      migrationActive.compareAndSet(false,migrationStatus);
    }
  }
,waitBeforeMigrationActivate,TimeUnit.MILLISECONDS);
}
