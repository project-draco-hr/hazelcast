{
  if (initialized) {
    esMigrationService.getQueue().clear();
  }
  int maxBackupCount=0;
  for (  final CMap cmap : concurrentMapManager.maps.values()) {
    maxBackupCount=Math.max(maxBackupCount,cmap.getBackupCount());
  }
  int[] indexesOfDead=new int[partitions.length];
  for (  PartitionInfo partition : partitions) {
    indexesOfDead[partition.getPartitionId()]=partition.getReplicaIndexOf(deadMember.getAddress());
  }
  Address deadAddress=deadMember.getAddress();
  for (  PartitionInfo partition : partitions) {
    partition.onDeadAddress(deadAddress);
  }
  Address thisAddress=concurrentMapManager.getThisAddress();
  if (deadAddress == null || deadAddress.equals(thisAddress)) {
    return;
  }
  for (  CMap cmap : concurrentMapManager.maps.values()) {
    cmap.onDisconnect(deadAddress);
    Object[] records=cmap.mapRecords.values().toArray();
    for (    Object recordObject : records) {
      if (recordObject != null) {
        Record record=(Record)recordObject;
        if (record.isLocked() && cmap.isMapForQueue()) {
          if (deadAddress.equals(record.getLock().getLockAddress())) {
            cmap.sendKeyToMaster(record.getKeyData());
          }
        }
        cmap.onDisconnect(record,deadAddress);
        if (record.isActive() && thisAddress.equals(partitions[record.getBlockId()].getOwner())) {
          cmap.markAsDirty(record);
          cmap.updateIndexes(record);
        }
      }
    }
  }
  if (concurrentMapManager.isMaster()) {
    for (int i=0; i < indexesOfDead.length; i++) {
      int indexOfDead=indexesOfDead[i];
      if (indexOfDead != -1) {
        PartitionInfo partition=partitions[i];
        if (indexOfDead <= maxBackupCount) {
          Address owner=partition.getOwner();
          Address target=partition.getReplicaAddress(maxBackupCount);
          if (owner != null && target != null) {
            MigrationRequestTask mrt=new MigrationRequestTask(i,owner,target,maxBackupCount,false);
            esMigrationService.execute(new Migrator(mrt));
          }
        }
      }
    }
    sendClusterRuntimeState();
    esMigrationService.execute(new Runnable(){
      public void run(){
        initRepartitioning();
      }
    }
);
  }
}
