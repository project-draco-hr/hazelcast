{
  Block blockReal=blocks[blockInfo.getBlockId()];
  if (!thisAddress.equals(blockInfo.getOwner())) {
    throw new RuntimeException("migrateBlock should be called from owner: " + blockInfo);
  }
  if (!blockInfo.isMigrating()) {
    throw new RuntimeException("migrateBlock cannot have non-migrating block: " + blockInfo);
  }
  if (blockInfo.getOwner().equals(blockInfo.getMigrationAddress())) {
    throw new RuntimeException("migrateBlock cannot have same owner and migrationAddress:" + blockInfo);
  }
  if (!node.isActive() || node.factory.restarted) {
    return;
  }
  if (concurrentMapManager.isSuperClient()) {
    return;
  }
  if (blockReal.isMigrationStarted())   return;
  blockReal.setMigrationStarted(true);
  blockReal.setOwner(blockInfo.getOwner());
  blockReal.setMigrationAddress(blockInfo.getMigrationAddress());
  logger.log(Level.FINEST,"migrate blockInfo " + blockInfo);
  List<Record> lsRecordsToMigrate=new ArrayList<Record>(1000);
  Collection<CMap> cmaps=concurrentMapManager.maps.values();
  for (  final CMap cmap : cmaps) {
    if (cmap.locallyOwnedMap != null) {
      cmap.locallyOwnedMap.reset();
    }
    for (    Record rec : cmap.mapRecords.values()) {
      if (rec.isActive() && concurrentMapManager.isOwned(rec)) {
        if (rec.getKey() == null || rec.getKey().size() == 0) {
          throw new RuntimeException("Record.key is null or empty " + rec.getKey());
        }
        if (rec.getBlockId() == blockInfo.getBlockId()) {
          Record recordCopy=rec.copy();
          lsRecordsToMigrate.add(recordCopy);
          cmap.markAsRemoved(rec);
        }
      }
    }
  }
  logger.log(Level.FINEST,"Migrating [" + lsRecordsToMigrate.size() + "] "+ blockInfo);
  final CountDownLatch latch=new CountDownLatch(lsRecordsToMigrate.size());
  for (  final Record rec : lsRecordsToMigrate) {
    final CMap cmap=concurrentMapManager.getMap(rec.getName());
    node.executorManager.executeMigrationTask(new FallThroughRunnable(){
      public void doRun(){
        try {
          concurrentMapManager.migrateRecord(cmap,rec);
        }
  finally {
          latch.countDown();
        }
      }
    }
);
  }
  node.executorManager.executeMigrationTask(new FallThroughRunnable(){
    public void doRun(){
      try {
        logger.log(Level.FINEST,"migrate blockInfo " + blockInfo + " await ");
        latch.await(10,TimeUnit.SECONDS);
        concurrentMapManager.enqueueAndReturn(new Processable(){
          public void process(){
            blockInfo.setOwner(blockInfo.getMigrationAddress());
            blockInfo.setMigrationAddress(null);
            completeMigration(blockInfo.getBlockId());
            sendCompletionInfo(blockInfo);
          }
        }
);
      }
 catch (      InterruptedException ignored) {
      }
    }
  }
);
}
