{
  try {
    if (!concurrentMapManager.node.isActive() || !concurrentMapManager.node.isMaster())     return;
    if (migrationRequestTask.isMigration() && migrationRequestTask.getReplicaIndex() == 0) {
      concurrentMapManager.enqueueAndWait(new Processable(){
        public void process(){
          concurrentMapManager.sendMigrationEvent(true,migrationRequestTask);
        }
      }
,100);
    }
    if (migrationRequestTask.getToAddress() == null) {
      concurrentMapManager.enqueueAndWait(new Processable(){
        public void process(){
          int partitionId=migrationRequestTask.getPartitionId();
          int replicaIndex=migrationRequestTask.getReplicaIndex();
          PartitionInfo partition=partitions[partitionId];
          partition.setReplicaAddress(replicaIndex,null);
          migratingPartition=null;
        }
      }
);
    }
 else {
      MemberImpl fromMember=null;
      Object result=Boolean.FALSE;
      if (migrationRequestTask.isMigration()) {
        fromMember=getMember(migrationRequestTask.getFromAddress());
      }
 else {
        final int partitionId=migrationRequestTask.getPartitionId();
        fromMember=getMember(partitions[partitionId].getOwner());
      }
      logger.log(Level.FINEST,"Started Migration : " + migrationRequestTask);
      if (fromMember != null) {
        migrationRequestTask.setFromAddress(fromMember.getAddress());
        DistributedTask task=new DistributedTask(migrationRequestTask,fromMember);
        concurrentMapManager.enqueueAndWait(new Processable(){
          public void process(){
            addActiveMigration(migrationRequestTask);
          }
        }
);
        Future future=concurrentMapManager.node.factory.getExecutorService().submit(task);
        try {
          result=future.get(600,TimeUnit.SECONDS);
        }
 catch (        Throwable e) {
          logger.log(Level.WARNING,"Failed migrating from " + fromMember);
        }
      }
 else {
        result=Boolean.TRUE;
      }
      logger.log(Level.FINEST,"Finished Migration : " + migrationRequestTask);
      if (Boolean.TRUE.equals(result)) {
        concurrentMapManager.enqueueAndWait(new ProcessMigrationResult(migrationRequestTask),10000);
      }
 else {
        logger.log(Level.WARNING,"Migration task has failed => " + migrationRequestTask);
        concurrentMapManager.enqueueAndWait(new Processable(){
          public void process(){
            compareAndSetActiveMigratingPartition(migrationRequestTask,null);
          }
        }
);
      }
    }
  }
 catch (  Throwable t) {
    logger.log(Level.WARNING,"Error [" + t.getClass() + ": "+ t.getMessage()+ "] "+ "while executing "+ migrationRequestTask);
    logger.log(Level.FINEST,t.getMessage(),t);
  }
}
