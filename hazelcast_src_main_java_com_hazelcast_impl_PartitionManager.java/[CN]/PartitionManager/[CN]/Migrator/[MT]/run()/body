{
  try {
    if (!node.isActive() || !node.isMaster()) {
      return;
    }
    if (migrationRequestOp.isMigration() && migrationRequestOp.getReplicaIndex() == 0) {
      node.clusterManager.enqueueAndWait(new Processable(){
        public void process(){
          node.concurrentMapManager.sendMigrationEvent(true,migrationRequestOp);
        }
      }
,100);
    }
    if (migrationRequestOp.getToAddress() == null) {
      logger.log(Level.FINEST,"Fixing partition, " + migrationRequestOp.getReplicaIndex() + ". replica of partition["+ migrationRequestOp.getPartitionId()+ "] should be removed.");
      node.clusterManager.enqueueAndWait(new Processable(){
        public void process(){
          int partitionId=migrationRequestOp.getPartitionId();
          int replicaIndex=migrationRequestOp.getReplicaIndex();
          PartitionInfo partition=partitions[partitionId];
          partition.setReplicaAddress(replicaIndex,null);
          migratingPartition=null;
        }
      }
);
    }
 else {
      MemberImpl fromMember=null;
      Boolean result=Boolean.FALSE;
      final int partitionId=migrationRequestOp.getPartitionId();
      fromMember=getMember(partitions[partitionId].getOwner());
      logger.log(Level.FINEST,"Started Migration : " + migrationRequestOp);
      systemLogService.logPartition("Started Migration : " + migrationRequestOp);
      if (fromMember != null) {
        migrationRequestOp.setFromAddress(fromMember.getAddress());
        Invocation inv=node.nodeService.createSingleInvocation(PARTITION_SERVICE_NAME,migrationRequestOp,migrationRequestOp.getPartitionId()).setTryCount(3).setTryPauseMillis(1000).setTarget(migrationRequestOp.getFromAddress()).setReplicaIndex(migrationRequestOp.getReplicaIndex()).build();
        node.clusterManager.enqueueAndWait(new Processable(){
          public void process(){
            addActiveMigration(migrationRequestOp);
          }
        }
);
        Future future=inv.invoke();
        try {
          result=(Boolean)IOUtil.toObject(future.get(partitionMigrationTimeout,TimeUnit.SECONDS));
        }
 catch (        Throwable e) {
          logger.log(Level.WARNING,"Failed migrating from " + fromMember,e);
        }
      }
 else {
        result=Boolean.TRUE;
      }
      logger.log(Level.FINEST,"Finished Migration : " + migrationRequestOp);
      systemLogService.logPartition("Finished Migration : " + migrationRequestOp);
      if (Boolean.TRUE.equals(result)) {
        node.clusterManager.enqueueAndWait(new ProcessMigrationResult(migrationRequestOp),10000);
      }
 else {
        logger.log(Level.WARNING,"Migration task has failed => " + migrationRequestOp);
        systemLogService.logPartition("Migration task has failed => " + migrationRequestOp);
        node.clusterManager.enqueueAndWait(new Processable(){
          public void process(){
            compareAndSetActiveMigratingPartition(migrationRequestOp,null);
          }
        }
);
      }
    }
  }
 catch (  Throwable t) {
    logger.log(Level.WARNING,"Error [" + t.getClass() + ": "+ t.getMessage()+ "] "+ "while executing "+ migrationRequestOp);
    logger.log(Level.FINEST,t.getMessage(),t);
    systemLogService.logPartition("Failed! " + migrationRequestOp);
  }
}
