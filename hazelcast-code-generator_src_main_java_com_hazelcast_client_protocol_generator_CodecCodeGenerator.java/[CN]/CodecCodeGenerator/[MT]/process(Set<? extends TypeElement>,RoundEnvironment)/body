{
  messager.printMessage(Diagnostic.Kind.NOTE,"Processing code generator. round:" + (++round));
  try {
    for (    Element element : env.getElementsAnnotatedWith(Codec.class)) {
      TypeElement classElement=(TypeElement)element;
      Codec annotation=classElement.getAnnotation(Codec.class);
      if (annotation != null) {
        try {
          annotation.value();
        }
 catch (        MirroredTypeException mte) {
          TypeMirror value=mte.getTypeMirror();
          CodecModel.CUSTOM_CODEC_MAP.put(value.toString(),classElement);
        }
      }
    }
    for (    Element element : env.getElementsAnnotatedWith(GenerateCodec.class)) {
      register((TypeElement)element);
    }
    if (CodecModel.CUSTOM_CODEC_MAP.size() != CODEC_COUNT) {
      messager.printMessage(Diagnostic.Kind.NOTE,"Codec count do not match found codec count:" + CodecModel.CUSTOM_CODEC_MAP.size());
      return false;
    }
 else {
      messager.printMessage(Diagnostic.Kind.NOTE,"Codec count is validated. round:" + round);
    }
    for (    Lang lang : codecTemplateMap.keySet()) {
      generateContent(lang);
    }
  }
 catch (  Exception e) {
    messager.printMessage(Diagnostic.Kind.ERROR,e.getMessage());
    e.printStackTrace();
  }
  requestMap.clear();
  responseMap.clear();
  eventResponseMap.clear();
  return true;
}
