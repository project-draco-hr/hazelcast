{
  Map<String,String> mapPhrases=new HashMap<String,String>(1);
  int apoIndex=getApostropheIndex(sql,0);
  if (apoIndex != -1) {
    int phraseId=0;
    StringBuilder newSql=new StringBuilder();
    while (apoIndex != -1) {
      phraseId++;
      int start=apoIndex + 1;
      int end=getApostropheIndex(sql,apoIndex + 1);
      if (end == -1) {
        throw new RuntimeException("Missing ' in sql");
      }
      String phrase=sql.substring(start,end);
      String key="$" + phraseId;
      mapPhrases.put(key,phrase);
      String before=sql.substring(0,apoIndex);
      sql=sql.substring(end + 1);
      newSql.append(before);
      newSql.append(key);
      apoIndex=getApostropheIndex(sql,0);
    }
    newSql.append(sql);
    sql=newSql.toString();
  }
  Parser parser=new Parser();
  List<String> sqlTokens=parser.toPrefix(sql);
  List<Object> tokens=new ArrayList<Object>(sqlTokens.size());
  for (  String token : sqlTokens) {
    String finalToken=token;
    String value=mapPhrases.get(token);
    if (value != null) {
      finalToken=value;
    }
    tokens.add(finalToken);
  }
  if (tokens.size() == 0)   throw new RuntimeException("Invalid SQL :" + sql);
  if (tokens.size() == 1) {
    return eval(tokens.get(0));
  }
  root:   while (tokens.size() > 1) {
    for (int i=0; i < tokens.size(); i++) {
      Object tokenObj=tokens.get(i);
      if (tokenObj instanceof String && parser.isOperand((String)tokenObj)) {
        String token=(String)tokenObj;
        if ("=".equals(token) || "==".equals(token)) {
          int position=(i - 2);
          Object first=tokens.remove(position);
          Object second=tokens.remove(position);
          setOrAdd(tokens,position,equal(get((String)first),second));
        }
 else         if ("!=".equals(token)) {
          int position=(i - 2);
          Object first=tokens.remove(position);
          Object second=tokens.remove(position);
          setOrAdd(tokens,position,notEqual(get((String)first),second));
        }
 else         if (">".equals(token)) {
          int position=(i - 2);
          Object first=tokens.remove(position);
          Object second=tokens.remove(position);
          setOrAdd(tokens,position,greaterThan(get((String)first),(Comparable)second));
        }
 else         if (">=".equals(token)) {
          int position=(i - 2);
          Object first=tokens.remove(position);
          Object second=tokens.remove(position);
          setOrAdd(tokens,position,greaterEqual(get((String)first),(Comparable)second));
        }
 else         if ("<=".equals(token)) {
          int position=(i - 2);
          Object first=tokens.remove(position);
          Object second=tokens.remove(position);
          setOrAdd(tokens,position,lessEqual(get((String)first),(Comparable)second));
        }
 else         if ("<".equals(token)) {
          int position=(i - 2);
          Object first=tokens.remove(position);
          Object second=tokens.remove(position);
          setOrAdd(tokens,position,lessThan(get((String)first),(Comparable)second));
        }
 else         if ("LIKE".equalsIgnoreCase(token)) {
          int position=(i - 2);
          Object first=tokens.remove(position);
          Object second=tokens.remove(position);
          setOrAdd(tokens,position,like(get((String)first),(String)second));
        }
 else         if ("IN".equalsIgnoreCase(token)) {
          int position=i - 2;
          Object exp=tokens.remove(position);
          String[] values=((String)tokens.remove(position)).split(",");
          setOrAdd(tokens,position,Predicates.in(get((String)exp),values));
        }
 else         if ("NOT".equalsIgnoreCase(token)) {
          int position=i - 1;
          Object exp=tokens.remove(position);
          setOrAdd(tokens,position,Predicates.not(eval(exp)));
        }
 else         if ("BETWEEN".equalsIgnoreCase(token)) {
          int position=i - 3;
          Object expression=tokens.remove(position);
          Object from=tokens.remove(position);
          Object to=tokens.remove(position);
          setOrAdd(tokens,position,between(get((String)expression),(Comparable)from,(Comparable)to));
        }
 else         if ("AND".equalsIgnoreCase(token)) {
          int position=i - 2;
          Object first=tokens.remove(position);
          Object second=tokens.remove(position);
          setOrAdd(tokens,position,and(eval(first),eval(second)));
        }
 else         if ("OR".equalsIgnoreCase(token)) {
          int position=i - 2;
          Object first=tokens.remove(position);
          Object second=tokens.remove(position);
          setOrAdd(tokens,position,or(eval(first),eval(second)));
        }
 else         throw new RuntimeException("Unknown token " + token);
        continue root;
      }
    }
  }
  return (Predicate)tokens.get(0);
}
