{
  long now=Clock.currentTimeMillis();
  List<DelayedEntry> entries=new ArrayList<DelayedEntry>(partitionCount);
  for (int partitionId=0; partitionId < partitionCount; partitionId++) {
    RecordStore recordStore=getRecordStoreOrNull(mapName,partitionId);
    if (!hasEntryInWriteBehindQueue(recordStore)) {
      continue;
    }
    List<DelayedEntry> entriesToStore=getEntriesToStore(recordStore,now);
    if (!isPartitionLocal(partitionId)) {
      if (now > lastRunTimeMillis + backupRunIntervalMillis) {
        doInBackup(entriesToStore,partitionId);
      }
    }
 else {
      entries.addAll(entriesToStore);
    }
  }
  if (!entries.isEmpty()) {
    Map<Integer,List<DelayedEntry>> failuresPerPartition=writeBehindProcessor.process(entries);
    removeFinishedStoreOperationsFromQueues(mapName,entries);
    reAddFailedStoreOperationsToQueues(mapName,failuresPerPartition);
    lastRunTimeMillis=now;
  }
  notifyFlush();
}
