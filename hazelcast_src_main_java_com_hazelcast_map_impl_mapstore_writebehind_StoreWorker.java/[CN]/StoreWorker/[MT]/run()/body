{
  final long now=Clock.currentTimeMillis();
  final String mapName=this.mapName;
  final MapServiceContext mapServiceContext=this.mapServiceContext;
  final NodeEngine nodeEngine=mapServiceContext.getNodeEngine();
  final ClusterService clusterService=nodeEngine.getClusterService();
  final InternalPartitionService partitionService=nodeEngine.getPartitionService();
  final Address thisAddress=clusterService.getThisAddress();
  final int partitionCount=partitionService.getPartitionCount();
  final List<DelayedEntry> entries=new ArrayList<DelayedEntry>();
  for (int partitionId=0; partitionId < partitionCount; partitionId++) {
    final InternalPartition partition=partitionService.getPartition(partitionId,false);
    final Address owner=partition.getOwnerOrNull();
    final RecordStore recordStore=getRecordStoreOrNull(mapName,partitionId);
    if (owner == null || recordStore == null) {
      continue;
    }
    final WriteBehindQueue<DelayedEntry> queue=getWriteBehindQueue(recordStore);
    final int flushCount=getNumberOfFlushedEntries(recordStore);
    filterWriteBehindQueue(now,flushCount,entries,queue);
    if (entries.isEmpty()) {
      continue;
    }
    if (!owner.equals(thisAddress)) {
      if (now > lastRunTime + backupRunIntervalTime) {
        doInBackup(entries,partitionId);
      }
      continue;
    }
  }
  if (!entries.isEmpty()) {
    Map<Integer,List<DelayedEntry>> failuresPerPartition=writeBehindProcessor.process(entries);
    removeFinishedStoreOperationsFromQueues(mapName,entries);
    readdFailedStoreOperationsToQueues(mapName,failuresPerPartition);
    lastRunTime=now;
  }
}
