{
  backupRecordInfos=new ArrayList<RecordInfo>();
  backupEntrySet=new ArrayList<Map.Entry<Data,Data>>();
  int partitionId=getPartitionId();
  final MapServiceContext mapServiceContext=mapService.getMapServiceContext();
  this.recordStore=mapServiceContext.getRecordStore(partitionId,name);
  RecordStore recordStore=this.recordStore;
  Set<Map.Entry<Data,Data>> entries=entrySet.getEntrySet();
  InternalPartitionService partitionService=getNodeEngine().getPartitionService();
  Set<Data> keysToInvalidate=new HashSet<Data>();
  for (  Map.Entry<Data,Data> entry : entries) {
    Data dataKey=entry.getKey();
    Data dataValue=entry.getValue();
    if (partitionId == partitionService.getPartitionId(dataKey)) {
      Data dataOldValue=null;
      if (initialLoad) {
        recordStore.putFromLoad(dataKey,dataValue,-1);
      }
 else {
        dataOldValue=mapServiceContext.toData(recordStore.put(dataKey,dataValue,-1));
      }
      mapServiceContext.interceptAfterPut(name,dataValue);
      EntryEventType eventType=dataOldValue == null ? EntryEventType.ADDED : EntryEventType.UPDATED;
      final MapEventPublisher mapEventPublisher=mapServiceContext.getMapEventPublisher();
      mapEventPublisher.publishEvent(getCallerAddress(),name,eventType,dataKey,dataOldValue,dataValue);
      keysToInvalidate.add(dataKey);
      final Record record=recordStore.getRecordOrNull(dataKey);
      if (record == null) {
        continue;
      }
      if (mapContainer.getWanReplicationPublisher() != null && mapContainer.getWanMergePolicy() != null) {
        final Data dataValueAsData=mapServiceContext.toData(dataValue);
        final EntryView entryView=EntryViews.createSimpleEntryView(dataKey,dataValueAsData,record);
        mapEventPublisher.publishWanReplicationUpdate(name,entryView);
      }
      backupEntrySet.add(entry);
      RecordInfo replicationInfo=Records.buildRecordInfo(recordStore.getRecord(dataKey));
      backupRecordInfos.add(replicationInfo);
      evict(false);
    }
  }
  invalidateNearCaches(keysToInvalidate);
}
