{
  long timeoutInMillis=unit.toMillis(timeout);
  int sleep=1000;
  while (timeoutInMillis > 0) {
    while (timeoutInMillis > 0 && shouldWaitMigrationOrBackups(Level.INFO)) {
      try {
        Thread.sleep(sleep);
      }
 catch (      InterruptedException ignored) {
      }
      timeoutInMillis-=sleep;
    }
    if (timeoutInMillis <= 0) {
      break;
    }
    if (node.isMaster()) {
      syncPartitionRuntimeState();
    }
 else {
      while (timeoutInMillis > 0 && hasOnGoingMigrationMaster(Level.WARNING)) {
        logger.info("Waiting for the master node to complete remaining migrations!");
        try {
          Thread.sleep(sleep);
        }
 catch (        InterruptedException ignored) {
        }
        timeoutInMillis-=sleep;
      }
      if (timeoutInMillis <= 0) {
        break;
      }
    }
    long start=Clock.currentTimeMillis();
    boolean ok=checkReplicaSyncState();
    timeoutInMillis-=(Clock.currentTimeMillis() - start);
    if (ok) {
      logger.finest("Replica sync state before shutdown is OK");
      return true;
    }
 else {
      if (timeoutInMillis <= 0) {
        break;
      }
      logger.info("Some backup replicas are inconsistent with primary, " + "waiting for synchronization. Timeout: " + timeoutInMillis + "ms");
      try {
        Thread.sleep(sleep);
      }
 catch (      InterruptedException ignored) {
      }
      timeoutInMillis-=sleep;
    }
  }
  return false;
}
