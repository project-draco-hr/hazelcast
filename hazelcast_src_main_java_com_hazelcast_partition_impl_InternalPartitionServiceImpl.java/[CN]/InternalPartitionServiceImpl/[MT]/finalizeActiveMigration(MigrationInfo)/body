{
  if (activeMigrations.containsKey(migrationInfo.getPartitionId())) {
    lock.lock();
    try {
      if (activeMigrations.containsValue(migrationInfo)) {
        if (migrationInfo.startProcessing()) {
          try {
            Address thisAddress=node.getThisAddress();
            boolean source=thisAddress.equals(migrationInfo.getSource());
            boolean destination=thisAddress.equals(migrationInfo.getDestination());
            if (source || destination) {
              int partitionId=migrationInfo.getPartitionId();
              InternalPartitionImpl migratingPartition=getPartitionImpl(partitionId);
              Address ownerAddress=migratingPartition.getOwner();
              boolean success=migrationInfo.getDestination().equals(ownerAddress);
              MigrationEndpoint endpoint=source ? MigrationEndpoint.SOURCE : MigrationEndpoint.DESTINATION;
              FinalizeMigrationOperation op=new FinalizeMigrationOperation(endpoint,success);
              op.setPartitionId(partitionId).setNodeEngine(nodeEngine).setValidateTarget(false).setService(this);
              nodeEngine.getOperationService().executeOperation(op);
            }
          }
 catch (          Exception e) {
            logger.warning(e);
          }
 finally {
            migrationInfo.doneProcessing();
          }
        }
 else {
          logger.info("Scheduling finalization of " + migrationInfo + ", because migration process is currently running.");
          nodeEngine.getExecutionService().schedule(new Runnable(){
            @Override public void run(){
              finalizeActiveMigration(migrationInfo);
            }
          }
,3,TimeUnit.SECONDS);
        }
      }
    }
  finally {
      lock.unlock();
    }
  }
}
