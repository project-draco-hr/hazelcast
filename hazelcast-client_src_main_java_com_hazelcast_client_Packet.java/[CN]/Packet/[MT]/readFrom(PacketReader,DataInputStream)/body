{
  final ByteBuffer readHeaderBuffer=packetReader.readHeaderBuffer;
  final int headerSize=dis.readInt();
  int keySize=dis.readInt();
  int valueSize=dis.readInt();
  byte packetVersion=dis.readByte();
  if (packetVersion != PACKET_VERSION) {
    throw new ClusterClientException("Invalid packet version. Expected:" + PACKET_VERSION + ", Found:"+ packetVersion);
  }
  readHeaderBuffer.clear();
  readHeaderBuffer.limit(headerSize);
  dis.readFully(readHeaderBuffer.array(),0,headerSize);
  this.operation=ClusterOperation.create(readHeaderBuffer.getShort());
  int blockId=readHeaderBuffer.getInt();
  this.threadId=readHeaderBuffer.getInt();
  byte booleans=readHeaderBuffer.get();
  if (ByteUtil.isTrue(booleans,1)) {
    timeout=readHeaderBuffer.getLong();
  }
  if (ByteUtil.isTrue(booleans,2)) {
    ttl=readHeaderBuffer.getLong();
  }
  if (ByteUtil.isTrue(booleans,4)) {
    longValue=readHeaderBuffer.getLong();
  }
  if (!ByteUtil.isTrue(booleans,7)) {
    throw new ClusterClientException("LockAddress cannot be sent to the client!" + operation);
  }
  this.callId=readHeaderBuffer.getLong();
  this.responseType=readHeaderBuffer.get();
  int nameLength=readHeaderBuffer.getInt();
  if (nameLength > 0) {
    byte[] b=new byte[nameLength];
    readHeaderBuffer.get(b);
    this.name=new String(b);
  }
  int indexCount=readHeaderBuffer.get();
  keyHash=readHeaderBuffer.getInt();
  valueHash=readHeaderBuffer.getInt();
  key=new byte[keySize];
  dis.readFully(key);
  value=new byte[valueSize];
  dis.readFully(value);
}
