{
  headerSize=dis.readInt();
  keySize=dis.readInt();
  valueSize=dis.readInt();
  headerInBytes=new byte[headerSize];
  dis.read(headerInBytes);
  ByteArrayInputStream bis=new ByteArrayInputStream(headerInBytes);
  DataInputStream dis2=new DataInputStream(bis);
  this.operation=ClusterOperation.create(dis2.readByte());
  this.blockId=dis2.readInt();
  this.threadId=dis2.readInt();
  byte booleans=dis2.readByte();
  if (ByteUtil.isTrue(booleans,0)) {
    lockCount=dis2.readInt();
  }
  if (ByteUtil.isTrue(booleans,1)) {
    timeout=dis2.readLong();
  }
  if (ByteUtil.isTrue(booleans,2)) {
    ttl=dis2.readLong();
  }
  if (ByteUtil.isTrue(booleans,3)) {
    txnId=dis2.readLong();
  }
  if (ByteUtil.isTrue(booleans,4)) {
    longValue=dis2.readLong();
  }
  if (ByteUtil.isTrue(booleans,5)) {
    version=dis2.readLong();
  }
  if (!ByteUtil.isTrue(booleans,7)) {
    throw new RuntimeException("LockAddress cannot be sent to the client!" + operation);
  }
  this.callId=dis2.readLong();
  this.responseType=dis2.readByte();
  int nameLength=dis2.readInt();
  if (nameLength > 0) {
    byte[] b=new byte[nameLength];
    dis2.read(b);
    this.name=new String(b);
  }
  indexCount=dis2.readByte();
  for (int i=0; i < indexCount; i++) {
    indexes[i]=dis2.readLong();
    indexTypes[i]=dis2.readByte();
  }
  key=new byte[keySize];
  dis.read(key);
  value=new byte[valueSize];
  dis.read(value);
}
