{
  if (localOnly) {
    return simpleExecution.cancel(mayInterruptIfRunning);
  }
 else {
    boolean cancelled=false;
    try {
      final Callable<Boolean> callCancel=new CancelationTask(executionId,thisAddress,mayInterruptIfRunning);
      if (innerFutureTask.getMembers() == null) {
        DistributedTask<Boolean> task=null;
        if (innerFutureTask.getKey() != null) {
          task=new DistributedTask<Boolean>(callCancel,innerFutureTask.getKey());
        }
 else         if (innerFutureTask.getMember() != null) {
          task=new DistributedTask<Boolean>(callCancel,innerFutureTask.getMember());
        }
 else {
          task=new DistributedTask<Boolean>(callCancel,randomTarget);
        }
        Hazelcast.getExecutorService().execute(task);
        cancelled=task.get();
      }
 else {
        final MultiTask<Boolean> task=new MultiTask<Boolean>(callCancel,innerFutureTask.getMembers());
        Hazelcast.getExecutorService().execute(task);
        final Collection<Boolean> results=task.get();
        for (        final Boolean result : results) {
          if (result)           cancelled=true;
        }
      }
    }
 catch (    final Throwable t) {
      cancelled=true;
    }
 finally {
      if (cancelled) {
        handleStreamResponse(OBJECT_CANCELLED);
      }
    }
    return cancelled;
  }
}
