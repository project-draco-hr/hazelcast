{
  final String name="test";
  final String FIND_ME="find-me";
  final String DONT_FIND_ME="dont-find-me";
  final int nodes=5;
  final int entryPerNode=1000;
  final int modulo=10;
  final CountDownLatch latch=new CountDownLatch(nodes);
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(nodes);
  final Config config=new Config();
  config.getMapConfig(name).addMapIndexConfig(new MapIndexConfig("name",false));
  for (int n=0; n < nodes; n++) {
    new Thread(){
      public void run(){
        HazelcastInstance hz=factory.newHazelcastInstance(config);
        IMap<Object,Object> map=hz.getMap(name);
        for (int i=0; i < entryPerNode; i++) {
          String id=UuidUtil.buildRandomUuidString();
          String name;
          if (i % modulo == 0) {
            name=FIND_ME;
          }
 else {
            name=DONT_FIND_ME;
          }
          QueryValue d=new QueryValue(name,id);
          map.put(id,d);
        }
        latch.countDown();
      }
    }
.start();
  }
  assertTrue(latch.await(5,TimeUnit.MINUTES));
  Collection<HazelcastInstance> instances=factory.getAllHazelcastInstances();
  assertEquals(nodes,instances.size());
  final int expected=entryPerNode / modulo * nodes;
  for (  HazelcastInstance hz : instances) {
    IMap<Object,Object> map=hz.getMap(name);
    EntryObject e=new PredicateBuilder().getEntryObject();
    Predicate p=e.get("name").equal(FIND_ME);
    for (int i=0; i < 10; i++) {
      int size=map.values(p).size();
      assertEquals(expected,size);
      Thread.sleep(10);
    }
  }
}
