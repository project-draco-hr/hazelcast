{
  long timeout=unit.toMillis(time);
  if (timeout < 0)   timeout=0;
  final long maxCallTimeout=callTimeout * 2 > 0 ? callTimeout * 2 : Long.MAX_VALUE;
  final boolean longPolling=timeout > maxCallTimeout;
  int pollCount=0;
  while (timeout >= 0) {
    final long pollTimeout=Math.min(maxCallTimeout,timeout);
    final long start=Clock.currentTimeMillis();
    final Object response;
    try {
      response=responseQ.poll(pollTimeout,TimeUnit.MILLISECONDS);
      timeout=decrementTimeout(timeout,Clock.currentTimeMillis() - start);
    }
 catch (    InterruptedException e) {
      logger.log(Level.FINEST,Thread.currentThread().getName() + " is interrupted while waiting " + "response for operation "+ op);
      if (!isActive()) {
        return e;
      }
      continue;
    }
    pollCount++;
    if (response instanceof Throwable) {
      final InvocationAction action=op.onException((Throwable)response);
      final int localInvokeCount=invokeCount;
      if (action == InvocationAction.RETRY_INVOCATION && localInvokeCount < tryCount && timeout > 0) {
        if (localInvokeCount > 3) {
          try {
            Thread.sleep(tryPauseMillis);
          }
 catch (          InterruptedException e) {
            return e;
          }
        }
        timeout=decrementTimeout(timeout,tryPauseMillis);
        if (localInvokeCount > 5 && localInvokeCount % 10 == 0) {
          logger.log(Level.WARNING,"Retrying invocation: " + toString());
        }
        doInvoke();
      }
 else       if (action == InvocationAction.CONTINUE_WAIT) {
      }
 else {
        if (remote) {
          ExceptionUtil.fixRemoteStackTrace((Throwable)response,Thread.currentThread().getStackTrace());
        }
        return response;
      }
    }
 else     if (response != null) {
      return response;
    }
 else     if (longPolling) {
      final Address target=getTarget();
      if (nodeEngine.getThisAddress().equals(target)) {
        continue;
      }
      logger.log(Level.WARNING,"No response for " + pollTimeout + " ms. "+ toString());
      boolean executing=isOperationExecuting(target);
      if (!executing) {
        Object obj=responseQ.poll();
        if (obj != null) {
          return obj;
        }
        return new OperationTimeoutException("No response for " + (pollTimeout * pollCount) + " ms. Aborting invocation! "+ toString());
      }
    }
  }
  return TIMEOUT_RESPONSE;
}
