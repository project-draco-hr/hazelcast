{
  final Address deadAddress=deadMember.getAddress();
  final Address thisAddress=node.getThisAddress();
  if (deadAddress == null || deadAddress.equals(thisAddress)) {
    return;
  }
  if (!hasStorageMember()) {
    reset();
  }
  if (!deadMember.isLiteMember()) {
    clearTaskQueues();
    lock.lock();
    try {
      final boolean migrationStatus=migrationActive.getAndSet(false);
      int[] indexesOfDead=new int[partitions.length];
      for (      PartitionInfo partition : partitions) {
        indexesOfDead[partition.getPartitionId()]=partition.getReplicaIndexOf(deadAddress);
      }
      for (      PartitionInfo partition : partitions) {
        while (partition.onDeadAddress(deadAddress))         ;
      }
      fixReplicasAndPartitionsForDead(deadMember,indexesOfDead);
      final long waitBeforeMigrationActivate=node.groupProperties.CONNECTION_MONITOR_INTERVAL.getLong() * node.groupProperties.CONNECTION_MONITOR_MAX_FAULTS.getInteger() * 10;
      nodeService.schedule(new Runnable(){
        public void run(){
          migrationActive.compareAndSet(false,migrationStatus);
        }
      }
,waitBeforeMigrationActivate,TimeUnit.MILLISECONDS);
    }
  finally {
      lock.unlock();
    }
  }
}
