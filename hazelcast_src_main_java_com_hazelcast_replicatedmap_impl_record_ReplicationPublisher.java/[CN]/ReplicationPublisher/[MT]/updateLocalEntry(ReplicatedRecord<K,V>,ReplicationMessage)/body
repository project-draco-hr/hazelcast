{
  final VectorClockTimestamp currentVectorClockTimestamp=localEntry.getVectorClockTimestamp();
  final VectorClockTimestamp updateVectorClockTimestamp=update.getVectorClockTimestamp();
  if (isOldTombstone(localEntry)) {
    applyTheUpdate(update,localEntry);
  }
 else   if (VectorClockTimestamp.happenedBefore(currentVectorClockTimestamp,updateVectorClockTimestamp)) {
    applyTheUpdate(update,localEntry);
  }
 else   if (VectorClockTimestamp.happenedBefore(updateVectorClockTimestamp,currentVectorClockTimestamp)) {
    return;
  }
 else   if (!updateVectorClockTimestamp.equals(currentVectorClockTimestamp)) {
    if (localEntry.getLatestUpdateHash() >= update.getUpdateHash()) {
      applyTheUpdate(update,localEntry);
    }
 else {
      VectorClockTimestamp newTimestamp=localEntry.applyAndIncrementVectorClock(updateVectorClockTimestamp,localMember);
      Object key=update.getKey();
      V v=localEntry.getValueInternal();
      V value=v instanceof Data ? (V)nodeEngine.toObject(v) : v;
      long ttlMillis=update.getTtlMillis();
      int latestUpdateHash=localEntry.getLatestUpdateHash();
      ReplicationMessage message=new ReplicationMessage(name,key,value,newTimestamp,localMember,latestUpdateHash,ttlMillis);
      distributeReplicationMessage(message,true);
    }
  }
 else {
    LOGGER.finest("Received an update with the same state of vector clock I currently have. " + "This can happened during initialization. Ignoring the update.");
  }
}
