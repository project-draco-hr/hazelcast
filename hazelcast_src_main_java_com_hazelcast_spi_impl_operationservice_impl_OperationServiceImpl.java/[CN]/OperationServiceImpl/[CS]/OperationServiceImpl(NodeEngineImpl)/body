{
  this.nodeEngine=nodeEngine;
  this.node=nodeEngine.getNode();
  this.logger=node.getLogger(OperationService.class);
  this.metricsRegistry=nodeEngine.getMetricsRegistry();
  this.serializationService=nodeEngine.getSerializationService();
  this.invocationLogger=nodeEngine.getLogger(Invocation.class);
  GroupProperties groupProperties=node.getGroupProperties();
  this.defaultCallTimeoutMillis=groupProperties.OPERATION_CALL_TIMEOUT_MILLIS.getLong();
  this.backpressureRegulator=new BackpressureRegulator(groupProperties,logger);
  int coreSize=Runtime.getRuntime().availableProcessors();
  boolean reallyMultiCore=coreSize >= CORE_SIZE_CHECK;
  int concurrencyLevel=reallyMultiCore ? coreSize * CORE_SIZE_FACTOR : CONCURRENCY_LEVEL;
  this.invocationsRegistry=new InvocationRegistry(nodeEngine,logger,backpressureRegulator,concurrencyLevel);
  this.operationBackupHandler=new OperationBackupHandler(this);
  this.responsePacketExecutor=new AsyncResponsePacketHandler(node.getHazelcastThreadGroup(),logger,new ResponsePacketHandlerImpl(logger,node.getSerializationService(),invocationsRegistry));
  this.operationExecutor=new ClassicOperationExecutor(groupProperties,node.loggingService,node.getThisAddress(),new OperationRunnerFactoryImpl(this),node.getHazelcastThreadGroup(),node.getNodeExtension(),metricsRegistry);
  this.isStillRunningService=new IsStillRunningService(operationExecutor,nodeEngine,logger);
  ExecutionService executionService=nodeEngine.getExecutionService();
  this.asyncExecutor=executionService.register(ExecutionService.ASYNC_EXECUTOR,coreSize,ASYNC_QUEUE_CAPACITY,ExecutorType.CONCRETE);
  this.slowOperationDetector=initSlowOperationDetector();
  metricsRegistry.scanAndRegister(this,"operation");
}
