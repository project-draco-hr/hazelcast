{
  NodeEngine nodeEngine=getNodeEngine();
  SerializationService serializationService=nodeEngine.getSerializationService();
  ObjectDataInput in=null;
  if (migrationInfo.startProcessing()) {
    try {
      final byte[] taskData=IOUtil.decompress(zippedTaskData);
      in=serializationService.createObjectDataInput(taskData);
      int size=in.readInt();
      tasks=new ArrayList<Operation>(size);
      for (int i=0; i < size; i++) {
        Operation task=(Operation)serializationService.readObject(in);
        tasks.add(task);
      }
      if (taskCount != tasks.size()) {
        getLogger().log(Level.SEVERE,"Migration task count mismatch! => " + "expected-count: " + size + ", actual-count: "+ tasks.size()+ "\nfrom: "+ migrationInfo.getFromAddress()+ ", partition: "+ getPartitionId()+ ", replica: "+ getReplicaIndex());
      }
      success=runMigrationTasks();
    }
 catch (    Throwable e) {
      Level level=Level.WARNING;
      if (e instanceof IllegalStateException) {
        level=Level.FINEST;
      }
      getLogger().log(level,e.getMessage(),e);
      success=false;
    }
 finally {
      migrationInfo.doneProcessing();
      IOUtil.closeResource(in);
    }
  }
 else {
    getLogger().log(Level.WARNING,"Migration is cancelled -> " + migrationInfo);
    success=false;
  }
}
