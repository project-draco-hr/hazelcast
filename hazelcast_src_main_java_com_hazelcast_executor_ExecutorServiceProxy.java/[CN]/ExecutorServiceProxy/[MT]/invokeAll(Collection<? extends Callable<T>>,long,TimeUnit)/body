{
  if (unit == null) {
    throw new NullPointerException("unit must not be null");
  }
  if (tasks == null) {
    throw new NullPointerException("tasks must not be null");
  }
  long timeoutNanos=unit.toNanos(timeout);
  final List<Future<T>> futures=new ArrayList<Future<T>>(tasks.size());
  final List<Future<T>> result=new ArrayList<Future<T>>(tasks.size());
  boolean done=true;
  try {
    for (    Callable<T> task : tasks) {
      long start=System.nanoTime();
      int partitionId=getTaskPartitionId(task);
      futures.add(submitToPartitionOwner(task,partitionId,true));
      timeoutNanos-=System.nanoTime() - start;
      if (timeoutNanos <= 0L) {
        for (int i=0, size=futures.size(); i < size; i++) {
          result.add(futures.get(i));
        }
        return result;
      }
    }
    for (int i=0, size=futures.size(); i < size; i++) {
      long start=System.nanoTime();
      Object value;
      try {
        Future<T> future=futures.get(i);
        value=future.get(timeoutNanos,TimeUnit.NANOSECONDS);
      }
 catch (      ExecutionException e) {
        value=e;
      }
catch (      TimeoutException e) {
        done=false;
        for (int o=i; o < size; o++) {
          Future<T> f=futures.get(i);
          if (!f.isDone()) {
            result.add(f);
          }
 else {
            Object v;
            try {
              v=f.get();
            }
 catch (            ExecutionException ex) {
              v=ex;
            }
            result.add(new CompletedFuture<T>(getNodeEngine().getSerializationService(),v,getAsyncExecutor()));
          }
        }
        break;
      }
      result.add(new CompletedFuture<T>(getNodeEngine().getSerializationService(),value,getAsyncExecutor()));
      timeoutNanos-=System.nanoTime() - start;
    }
  }
 catch (  Throwable t) {
    t.printStackTrace();
  }
 finally {
    if (!done) {
      for (int i=0, size=result.size(); i < size; i++) {
        result.get(i).cancel(true);
      }
    }
    return result;
  }
}
